<?xml version="1.0" encoding="UTF-8"?>
<!-- -*- nxml -*- -->
<!-- TODO:
     * stop using GD, just check whether the determiner (or whatever) has some gender already
-->
<interchunk>

  <section-def-cats>
    <def-cat n="unknown">
      <cat-item tags="unknown"/>
    </def-cat>
    <def-cat n="np">
      <cat-item tags="np.*"/>
    </def-cat>
    <def-cat n="np_prnnom_og">
      <cat-item tags="np.*"/>
      <cat-item tags="prn.*.nom"/>
      <cat-item tags="prn.*.nom.*"/>
      <cat-item lemma="og" tags="cnjcoo.clb"/>
      <cat-item lemma="og" tags="cnjcoo"/>
    </def-cat>
    <def-cat n="nom">
      <cat-item tags="n.*"/>
      <cat-item tags="n.*.gen"/>
      <cat-item tags="n.*.gen.*"/>
      <cat-item tags="np.*"/>
    </def-cat>
    <def-cat n="nom_advnom">
      <cat-item tags="n.*"/>
      <cat-item tags="n.*.gen"/>
      <cat-item tags="n.*.gen.*"/>
      <cat-item tags="np.*"/>
      <cat-item tags="adv.n.*"/>
    </def-cat>
    <def-cat n="nind">
      <cat-item tags="n.*.ind"/>
      <cat-item tags="n.*.ind.*"/>
    </def-cat>
    <def-cat n="nind_nogen">
      <cat-item tags="n.*.ind"/>
      <cat-item tags="n.*.ind.sl-nt"/>
      <cat-item tags="n.*.ind.sl-m"/>
      <cat-item tags="n.*.ind.sl-mf"/>
      <cat-item tags="n.*.ind.sl-f"/>
      <cat-item tags="n.*.ind.sl-nt.*"/>
      <cat-item tags="n.*.ind.sl-m.*"/>
      <cat-item tags="n.*.ind.sl-mf.*"/>
      <cat-item tags="n.*.ind.sl-f.*"/>
    </def-cat>
    <def-cat n="nind_noadj">
      <cat-item lemma="n" tags="n.*.ind"/>
      <cat-item lemma="n" tags="n.*.ind.*"/>
      <cat-item lemma="n_n" tags="n.*.ind"/>
      <cat-item lemma="n_n" tags="n.*.ind.*"/>
      <cat-item lemma="n_n_n" tags="n.*.ind"/>
      <cat-item lemma="n_n_n" tags="n.*.ind.*"/>
      <cat-item lemma="n_n_n_n" tags="n.*.ind"/>
      <cat-item lemma="n_n_n_n" tags="n.*.ind.*"/>
    </def-cat>
    <def-cat n="nplind">
      <cat-item tags="n.*.pl.ind"/>
      <cat-item tags="n.*.pl.ind.*"/>
    </def-cat>
    <def-cat n="nkeepgenx">
      <cat-item tags="n.*.keepgenx"/>
      <cat-item tags="n.*.keepgenx.*"/>
    </def-cat>
    <def-cat n="ndef">
      <cat-item tags="n.*.def"/>
      <cat-item tags="n.*.def.*"/>
    </def-cat>
    <def-cat n="ncmpsplit">
      <cat-item tags="n.*.ind.cmp-split"/>
      <cat-item tags="n.*.ind.cmp-split.*"/>
    </def-cat>
    <def-cat n="ndef_OR_np_pers">
      <cat-item tags="n.*.def"/>
      <cat-item tags="n.*.def.*"/>
      <cat-item tags="np.ant"/>
      <cat-item tags="np.cog"/>
      <cat-item tags="np.ant.*"/>
      <cat-item tags="np.cog.*"/>
      <cat-item tags="unknown"/>
    </def-cat>
    <def-cat n="np_pers">
      <cat-item tags="np.ant"/>
      <cat-item tags="np.cog"/>
      <cat-item tags="np.ant.*"/>
      <cat-item tags="np.cog.*"/>
      <cat-item tags="unknown"/>
    </def-cat>
    <def-cat n="np_nonorg">
      <cat-item tags="np.ant"/>
      <cat-item tags="np.cog"/>
      <cat-item tags="np.top"/> <!-- so many toponyms allowed as cognomens -->
      <cat-item tags="np.ant.*"/>
      <cat-item tags="np.cog.*"/>
      <cat-item tags="np.top.*"/>
      <cat-item tags="unknown"/>
    </def-cat>
    <def-cat n="prep_gen">
      <cat-item lemma="gen-prep" tags="pr"/>
      <cat-item lemma="gen-prep" tags="det.*"/>
    </def-cat>
    <def-cat n="ngen">
      <cat-item tags="n.*.gen"/>
      <cat-item tags="n.*.gen.*"/>
    </def-cat>
    <def-cat n="ngendefORpl">
      <cat-item tags="n.*.def.gen"/>
      <cat-item tags="n.*.def.gen.*"/>
      <cat-item tags="n.*.pl.*.gen"/>
      <cat-item tags="n.*.pl.*.gen.*"/>
      <cat-item tags="n.*.sp.*.gen"/>
      <cat-item tags="n.*.sp.*.gen.*"/>
    </def-cat>
    <def-cat n="ngensgdef">
      <cat-item tags="n.*.sg.def.gen"/>
      <cat-item tags="n.*.sg.def.gen.*"/>
    </def-cat>
    <def-cat n="npldef">
      <cat-item tags="n.*.pl.def"/>
      <cat-item tags="n.*.pl.def.*"/>
      <cat-item tags="n.*.sp.def"/>
      <cat-item tags="n.*.sp.def.*"/>
    </def-cat>
    <def-cat n="detgen">
      <cat-item tags="det.*.gen"/>
      <cat-item tags="det.*.gen.*"/>
    </def-cat>
    <def-cat n="detind">
      <cat-item tags="det.*.ind"/>
      <cat-item tags="det.*.sg"/>
    </def-cat>
    <def-cat n="det">
      <cat-item tags="det.*"/>
    </def-cat>
    <def-cat n="det2adj">
      <cat-item lemma="det2adj" tags="adj.*"/>
    </def-cat>
    <def-cat n="detemph">
      <cat-item tags="det.emph.*"/>
    </def-cat>
    <def-cat n="detdemdef">
      <cat-item tags="det.dem.*.def"/>
    </def-cat>
    <def-cat n="advladj">
      <cat-item tags="adj.*.nt.sg.ind"/>
      <cat-item tags="adv"/>
    </def-cat>
    <def-cat n="anom_def">
      <cat-item lemma="adj_n"               tags="n.*.def.*"/>
      <cat-item lemma="adj_adj_n"           tags="n.*.def.*"/>
      <cat-item lemma="adj_adj_adj_n"       tags="n.*.def.*"/>
      <cat-item lemma="adj_n_n"             tags="n.*.def.*"/>
      <cat-item lemma="adj_adj_n_n"         tags="n.*.def.*"/>
      <cat-item lemma="adj_adj_adj_n_n"     tags="n.*.def.*"/>
      <cat-item lemma="adj_n_n_n"           tags="n.*.def.*"/>
      <cat-item lemma="adj_adj_n_n_n"       tags="n.*.def.*"/>
      <cat-item lemma="adj_adj_adj_n_n_n"   tags="n.*.def.*"/>
      <cat-item lemma="adj_n_n_n_n"         tags="n.*.def.*"/>
      <cat-item lemma="adj_adj_n_n_n_n"     tags="n.*.def.*"/>
      <cat-item lemma="adj_adj_adj_n_n_n_n" tags="n.*.def.*"/>
    </def-cat>
    <def-cat n="prn">
      <cat-item tags="prn.*"/>
    </def-cat>
    <def-cat n="prn_nom">
      <cat-item tags="prn.*.nom"/>
    </def-cat>
    <def-cat n="prn_acc">
      <cat-item tags="prn.*.acc"/>
    </def-cat>
    <def-cat n="prn_subj">
      <cat-item tags="prn.*.nt.*"/>
      <cat-item tags="prn.*.nt"/>
      <cat-item tags="det.*.expl.*"/>
      <cat-item tags="det.*.expl"/>
      <cat-item tags="prn.pers.*.nom"/>
    </def-cat>
    <def-cat n="sin">
      <cat-item lemma="detsin" tags="det.pos.*"/>
    </def-cat>
    <def-cat n="detpos_keep">
      <cat-item lemma="detpos-keep" tags="det.pos.*"/>
    </def-cat>
    <def-cat n="detpos">
      <cat-item tags="det.pos.*"/>
    </def-cat>
    <def-cat n="detitg">
      <cat-item tags="det.itg.*"/>
    </def-cat>
    <def-cat n="detdem">
      <cat-item tags="det.dem.*"/>
    </def-cat>
    <def-cat n="detqnt">
      <cat-item tags="det.qnt.*"/>
    </def-cat>
    <def-cat n="detnonpos">
      <cat-item tags="det.def.*"/>
      <cat-item tags="det.dem.*"/>
      <!-- <cat-item tags="det.emph.*"/> -->
      <cat-item tags="det.itg.*"/>
      <cat-item tags="det.qnt.*"/>
    </def-cat>
    <def-cat n="detqntpl">
      <cat-item tags="det.qnt.*.pl"/>
    </def-cat>
    <def-cat n="detqntunpl">
      <cat-item tags="det.qnt.un.pl"/>
    </def-cat>
    <def-cat n="detall">
      <cat-item lemma="detall" tags="det.qnt.*.pl"/>
    </def-cat>
    <def-cat n="detsamtlige_def">
      <cat-item lemma="detsamtlige" tags="det.qnt.def.*.pl"/>
    </def-cat>
    <def-cat n="detenhver">
      <cat-item lemma="detenhver" tags="det.qnt.*"/>
    </def-cat>

    <def-cat n="av_alle">
      <cat-item tags="pr.av alle"/>
    </def-cat>

    <def-cat n="vblex">
      <cat-item tags="vblex"/>
      <cat-item tags="vblex.*"/>
    </def-cat>
    <def-cat n="pr_OR_vblex">
      <cat-item tags="vblex"/>
      <cat-item tags="vblex.*"/>
      <cat-item tags="pr"/>
      <cat-item tags="pr.*"/>
    </def-cat>
    <def-cat n="aux">
      <cat-item lemma="aux" tags="vblex"/>
      <cat-item lemma="aux" tags="vblex.*"/>
    </def-cat>
    <def-cat n="auxpass" c="Auxiliary generated in t1x">
      <cat-item lemma="aux" tags="vblex.*.pasv"/>
    </def-cat>
    <def-cat n="infaux">
      <cat-item lemma="aux" tags="vblex.inf"/>
      <cat-item lemma="aux" tags="vblex.inf.*"/>
    </def-cat>
    <def-cat n="adv">
      <cat-item tags="adv"/>
      <cat-item tags="adv.*"/>
    </def-cat>
    <def-cat n="adv_movable">
      <cat-item tags="adv.movable"/>
      <cat-item tags="adv.movable.*"/>
    </def-cat>
    <def-cat n="adjsg">
      <cat-item tags="adj.*.sg.*"/>
    </def-cat>
    <def-cat n="prenom">
      <cat-item tags="adv"/>
      <cat-item tags="adv.*"/>
      <cat-item tags="adj.*"/>
      <cat-item tags="det.*"/>
      <cat-item tags="pr"/>
      <cat-item tags="pr.*"/>
    </def-cat>
    <def-cat n="prenom_OR_nom">
      <cat-item tags="adv"/>
      <cat-item tags="adv.*"/>
      <cat-item tags="adj.*"/>
      <cat-item tags="det.*"/>
      <cat-item tags="pr"/>
      <cat-item tags="pr.*"/>
      <cat-item tags="n.*"/>
      <cat-item tags="n.*.gen"/>
      <cat-item tags="n.*.gen.*"/>
      <cat-item tags="np.*"/>
    </def-cat>
    <def-cat n="infm">
      <cat-item lemma="infm" tags="part"/>
      <cat-item lemma="infm" tags="part.*"/>
    </def-cat>
    <def-cat n="cnjcoo">
      <cat-item tags="cnjcoo"/>
      <cat-item tags="cnjcoo.*"/>
    </def-cat>
    <def-cat n="lemq">
      <cat-item tags="vblex.lemq"/>
      <cat-item tags="vblex.lemq.*"/>
    </def-cat>
    <def-cat n="lemq-skip-n">
      <cat-item tags="vblex.lemq.lemq-skip-n"/>
      <cat-item tags="vblex.lemq.lemq-skip-n.*"/>
    </def-cat>
    <def-cat n="adjpart">
      <cat-item tags="vblex.pp"/>
      <cat-item tags="adj.pp"/>
      <cat-item tags="adj.pp.*"/>
    </def-cat>
    <def-cat n="adjpart_np_movable">
      <cat-item tags="vblex.pp.np-movable"/>
      <cat-item tags="adj.pp.np-movable"/>
      <cat-item tags="adj.pp.*.np-movable"/>
    </def-cat>
    <def-cat n="pasv-pp">
      <cat-item lemma="adj2vblex" tags="vblex.pp"/>
      <cat-item lemma="adj2vblex" tags="adj.pp"/>
      <cat-item lemma="adj2vblex" tags="adj.pp.*"/>
    </def-cat>
    <def-cat n="prep_nhead">
      <cat-item tags="pr.*.nhead"/>
    </def-cat>
    <def-cat n="prep_av">
      <cat-item tags="pr.av"/>
    </def-cat>
    <def-cat n="prep">
      <cat-item tags="pr.*"/>
      <cat-item tags="pr"/>
    </def-cat>
    <def-cat n="prep_som">
      <cat-item tags="pr.som"/>
    </def-cat>
    <def-cat n="sent">
      <cat-item tags="sent.*"/>
      <cat-item tags="sent"/>
    </def-cat>
    <def-cat n="needdet_adj_n">
      <cat-item lemma="needdet_adj_n" tags="n.*"/>
    </def-cat>
  </section-def-cats>

  <section-def-attrs>
    <def-attr n="a_nom">
      <attr-item tags="n"/>
      <attr-item tags="n.acr"/>
      <attr-item tags="np"/>
      <attr-item tags="np.top"/>
    </def-attr>
    <def-attr n="persona">
      <attr-item tags="p1"/>
      <attr-item tags="p2"/>
      <attr-item tags="p3"/>
    </def-attr>
    <def-attr n="a_verb">
      <attr-item tags="vblex"/>
      <attr-item tags="vblex.pstv"/>
    </def-attr>
    <def-attr n="temps">
      <attr-item tags="inf"/>
      <attr-item tags="imp"/>
      <attr-item tags="pres"/>
      <attr-item tags="pret"/>
      <attr-item tags="pp"/>
    </def-attr>
    <def-attr n="voice">
      <attr-item tags="pasv"/>
    </def-attr>
    <def-attr n="a_det">
      <attr-item tags="det"/>
      <attr-item tags="det.emph"/>
      <attr-item tags="det.dem"/>
      <attr-item tags="det.itg"/>
      <attr-item tags="det.qnt"/>
      <attr-item tags="det.qnt.neg"/>
      <attr-item tags="det.pos"/>
    </def-attr>
    <def-attr n="gen">
      <attr-item tags="m"/>
      <attr-item tags="mf"/>
      <attr-item tags="nt"/>
      <attr-item tags="f"/>
      <attr-item tags="GD"/>
    </def-attr>
    <def-attr n="sl-gen">
      <attr-item tags="sl-m"/>
      <attr-item tags="sl-mf"/>
      <attr-item tags="sl-nt"/>
      <attr-item tags="sl-f"/>
    </def-attr>
    <def-attr n="nbr">
      <attr-item tags="sg"/>
      <attr-item tags="pl"/>
      <attr-item tags="sp"/>
      <attr-item tags="ND"/>
    </def-attr>
    <def-attr n="cas">
      <attr-item tags="nom"/>
      <attr-item tags="gen"/>
      <attr-item tags="acc"/>
      <attr-item tags="CD"/>
    </def-attr>
    <def-attr n="a_casedrop" c="Mark that we'd like to drop gen-case in t3x">
      <attr-item tags="casedrop"/>
    </def-attr>
    <def-attr n="a_defdrop" c="Mark that we'd like to change defnes to ind in t3x">
      <attr-item tags="defdrop"/>
    </def-attr>
    <def-attr n="a_keepgenx" c="Mark that we'd like to keep gen-case of possessor (throw away prep)">
      <attr-item tags="keepgenx"/>
    </def-attr>
    <def-attr n="a_date">
      <attr-item tags="date"/>
    </def-attr>
    <def-attr n="a_cmp">
      <attr-item tags="cmp"/>
      <attr-item tags="cmp-split"/>
    </def-attr>
    <def-attr n="art">
      <attr-item tags="def"/>
      <attr-item tags="ind"/>
    </def-attr>
    <def-attr n="expl">
      <attr-item tags="expl"/>
    </def-attr>

    <def-attr n="gen_prep_override">
      <attr-item tags="pr_til"/>

      <attr-item tags="pr_av"/>
      <attr-item tags="pr_blant"/>
      <attr-item tags="pr_etter"/>
      <attr-item tags="pr_for"/>
      <attr-item tags="pr_frå"/>
      <attr-item tags="pr_før"/>
      <attr-item tags="pr_gjennom"/>
      <attr-item tags="pr_hos"/>
      <attr-item tags="pr_i"/>
      <attr-item tags="pr_med"/>
      <attr-item tags="pr_mellom"/>
      <attr-item tags="pr_mot"/>
      <attr-item tags="pr_om"/>
      <attr-item tags="pr_over"/>
      <attr-item tags="pr_per"/>
      <attr-item tags="pr_på"/>
      <attr-item tags="pr_rundt"/>
      <attr-item tags="pr_som"/>
      <attr-item tags="pr_uansett"/>
      <attr-item tags="pr_under"/>
      <attr-item tags="pr_unna"/>
      <attr-item tags="pr_ut"/>
      <attr-item tags="pr_ved"/>
    </def-attr>

  </section-def-attrs>


  <section-def-vars>
    <def-var n="caseFirstWord"/>
    <def-var n="det_gender"/>
    <def-var n="number_no_sp"/>
    <def-var n="adj_number"/>
    <def-var n="adj_gender"/>
    <def-var n="adj_defness"/>
    <def-var n="n_number"/>
    <def-var n="case"/>
    <def-var n="n_defness"/>
    <def-var n="lemh"/>
    <def-var n="pr_lemh"/>
    <def-var n="genpr"/>
    <def-var n="ana_gen"     c="nt or mf"/>
    <def-var n="ana_gen_m-f" c="m or f"/>
    <def-var n="ana_nbr"/>
    <def-var n="ana_temps" c="Last seen finite verb temps (pres/pret)"/>
  </section-def-vars>

  <section-def-lists>
    <def-list n="m_f_mf_GD">
      <list-item v="&lt;m&gt;"/>
      <list-item v="&lt;f&gt;"/>
      <list-item v="&lt;mf&gt;"/>
      <list-item v="&lt;GD&gt;"/>
      <list-item v="&lt;sl-m&gt;"/>
      <list-item v="&lt;sl-f&gt;"/>
      <list-item v="&lt;sl-mf&gt;"/>
      <list-item v="&lt;sl-GD&gt;"/>
    </def-list>
    <def-list n="nt_GD">
      <list-item v="&lt;nt&gt;"/>
      <list-item v="&lt;GD&gt;"/>
      <list-item v="&lt;sl-nt&gt;"/>
      <list-item v="&lt;sl-GD&gt;"/>
    </def-list>
  </section-def-lists>

  <section-def-macros>

    <!-- Macros which set concordance variables etc.: -->
    <def-macro n="switch_cases" npar="2"
               c="arg1: last word, which will be output first,
                  arg2: first word, which will be output last">
      <let><var n="caseFirstWord"/><get-case-from pos="1"><lit v="aa"/></get-case-from></let>
      <choose><when c="only if the last word was lower, do we switch cases">
        <test><equal><var n="caseFirstWord"/><lit v="aa"/></equal></test>
        <let><clip pos="1" part="lemh"/><get-case-from pos="2"><clip pos="1" part="lemh"/></get-case-from></let>
        <modify-case><clip pos="2" part="lemh"/><var n="caseFirstWord"/></modify-case>
      </when></choose>
    </def-macro>

    <def-macro n="get_case_from_detpos" npar="2">
      <!-- arg.1: possessed noun. arg.2: det.pos, gives typographic case -->
      <choose>
        <when>
          <test>
            <and>
              <equal><clip pos="2" part="lemh"/><lit v="De"/></equal>
              <equal><clip pos="2" part="a_det"/><lit-tag v="det.pos"/></equal>
              <equal><clip pos="2" part="persona"/><lit-tag v="p2"/></equal>
            </and>
          </test>
          <let><var n="lemh"/><clip pos="1" part="lemh"/></let>
        </when>
        <otherwise>
          <let><var n="lemh"/><get-case-from pos="2"><clip pos="1" part="lemh"/></get-case-from></let>
        </otherwise>
      </choose>
    </def-macro>
    <def-macro n="modify_case_detpos" npar="2">
      <!-- arg.1: possessed noun. arg.2: det.pos, gives typographic case
           Workaround for Polite forms.
      -->
      <choose>
        <when>
          <test><not>
            <and>
              <equal><clip pos="2" part="lemh"/><lit v="De"/></equal>
              <equal><clip pos="2" part="a_det"/><lit-tag v="det.pos"/></equal>
              <equal><clip pos="2" part="persona"/><lit-tag v="p2"/></equal>
            </and>
          </not></test>
          <modify-case><clip pos="2" part="lemh"/><clip pos="1" part="lemh"/></modify-case>
        </when>
      </choose>
    </def-macro>

    <def-macro n="set_det_gender1.n" npar="1"
               c="arg.1: noun. Sets variables for creating a new determiner.">

      <let><var n="number_no_sp"/><clip pos="1" part="nbr"/></let>
      <choose><when>
        <test><or>
          <equal><var n="number_no_sp"/><lit-tag v="sp"/></equal>
          <equal><var n="number_no_sp"/><lit v=""/></equal>
        </or></test>
        <let><var n="number_no_sp"/><lit-tag v="pl"/></let>
      </when></choose>
      <choose>
        <when>
          <test><equal><var n="number_no_sp"/><lit-tag v="sg"/></equal></test>
          <let><var n="det_gender"/><clip pos="1" part="gen"/></let>
          <choose>
            <when>
              <test><or>
                <equal><var n="det_gender"/><lit v=""/></equal>
                <and>
                  <equal><var n="number_no_sp"/><lit-tag v="sg"/></equal>
                  <equal><clip pos="1" part="gen"/><lit-tag v="GD"/></equal>
                </and>
              </or></test>
              <let><var n="det_gender"/><lit-tag v="m"/></let>
            </when>
          </choose>
        </when>
        <otherwise>
          <let><var n="det_gender"/><lit-tag v="un"/></let>
        </otherwise>
      </choose>
    </def-macro>

    <def-macro n="modify_det_gender2.n.det" npar="2"
               c="arg.1: noun, arg.2: determiner">
      <choose>
        <when>
          <test><and>
            <not><equal><clip pos="1" part="gen"/><lit v=""/></equal></not>
            <or> <!-- only change gender of det for singular nouns *or* if det is «kva for ein (av)» -->
              <equal><clip pos="2" part="a_det"/><lit-tag v="det.itg"/></equal>
              <not><equal><clip pos="1" part="nbr"/><lit-tag v="pl"/></equal></not>
            </or>
            <not><equal><clip pos="2" part="nbr"/><lit-tag v="pl"/></equal></not>
          </and></test>
          <let><clip pos="2" part="gen"/><clip pos="1" part="gen"/></let>
        </when>
      </choose>
    </def-macro>

    <def-macro n="set_ana" npar="1"
               c="arg.1: noun or verb. Set vars for for later use by modify_pp_gender">
      <choose>
        <when>
          <test><equal><var n="ana_temps"/><lit v=""/></equal></test>
          <let><var n="ana_temps"/><lit-tag v="pres"/></let>
        </when>
      </choose>
      <choose>
        <when>
          <test><and>
            <not><equal><clip pos="1" part="temps"/><lit v=""/></equal></not>
            <not><equal><clip pos="1" part="temps"/><lit-tag v="pp"/></equal></not>
            <not><equal><clip pos="1" part="temps"/><lit-tag v="inf"/></equal></not>
          </and></test>
          <let><var n="ana_temps"/><clip pos="1" part="temps"/></let>
        </when>
      </choose>

      <choose>
        <when>
          <test><and>
            <or>
              <equal><clip pos="1" part="nbr"/><lit-tag v="sg"/></equal>
              <begins-with><clip pos="1" part="a_nom"/><lit-tag v="np"/></begins-with>
            </or>
            <or>
              <equal><clip pos="1" part="gen"/><lit-tag v="mf"/></equal>
              <equal><clip pos="1" part="gen"/><lit-tag v="m"/></equal>
              <equal><clip pos="1" part="gen"/><lit-tag v="f"/></equal>
              <equal><clip pos="1" part="gen"/><lit-tag v="nt"/></equal>
            </or>
          </and></test>
          <let><var n="ana_nbr"/><clip pos="1" part="nbr"/></let>
          <let><var n="ana_gen"/><clip pos="1" part="gen"/></let>
          <choose><when>
            <test><or>
              <equal><var n="ana_gen"/><lit-tag v="f"/></equal>
              <equal><var n="ana_gen"/><lit-tag v="m"/></equal>
            </or></test>
            <let><var n="ana_gen_m-f"/><var n="ana_gen"/></let>
            <let><var n="ana_gen"/><lit-tag v="mf"/></let>
          </when></choose>
        </when>
        <when>
          <test><and>
            <equal><clip pos="1" part="nbr"/><lit-tag v="pl"/></equal>
            <not><equal><clip pos="1" part="a_date"/><lit-tag v="date"/></equal></not>
          </and></test>
          <let><var n="ana_nbr"/><clip pos="1" part="nbr"/></let>
          <let><var n="ana_gen"/><lit v=""/></let>
        </when>
      </choose>
    </def-macro>
    <def-macro n="modify_pp_gen_nbr" npar="1"
               c="arg.1: adj.pp / vblex.pp
                  Assumes set_ana only sets variable combinations that are OK for adj.pp's">
      <choose><when>
        <test><equal><clip pos="1" part="tags"/><lit-tag v="vblex.pp"/></equal></test>
        <let><clip pos="1" part="tags"/><lit-tag v="adj.pp.nt.sg.ind"/></let>
        <let><clip pos="1" part="lemh"/><lit v="adj"/></let>
      </when></choose>
      <choose><when>
        <test><not><equal><var n="ana_nbr"/><lit v=""/></equal></not></test>
        <let><clip pos="1" part="nbr"/><var n="ana_nbr"/></let>
        <let><clip pos="1" part="gen"/><var n="ana_gen"/></let>
      </when></choose>
      <choose><when>
        <test><equal><clip pos="1" part="nbr"/><lit-tag v="pl"/></equal></test>
        <let><clip pos="1" part="art"/><lit v=""/></let>
      </when></choose>
    </def-macro>
    <def-macro n="modify_prn_gen" npar="1"
               c="arg.1: prn">
      <choose><when>
        <test><equal><clip pos="1" part="gen"/><lit-tag v="GD"/></equal></test>
        <choose>
          <when>
            <test><equal><var n="ana_gen_m-f"/><lit v=""/></equal></test>
            <let><clip pos="1" part="gen"/><lit-tag v="m"/></let>
          </when>
          <otherwise>
            <let><clip pos="1" part="gen"/><var n="ana_gen_m-f"/></let>
          </otherwise>
        </choose>
      </when></choose>
    </def-macro>

    <def-macro n="set_n_defness" npar="2"
               c="arg.1: noun, arg.2: determiner
                  Make sure we have double definiteness marking, eg.:
                  disse.def friheter.ind => desse.def fridomane.def
                  Check that numbers don't mismatch to protect from certain mis-taggings.">
      <choose>
        <when>
          <test>
            <and>
              <equal><clip pos="1" part="art"/><lit-tag v="ind"/></equal>
              <equal caseless="yes"><clip pos="2" part="lemh"/><lit v="detdd"/></equal>
              <not><or>
                <and><equal><clip pos="1" part="nbr"/><lit-tag v="pl"/></equal>
                     <equal><clip pos="2" part="nbr"/><lit-tag v="sg"/></equal></and>
                <and><equal><clip pos="2" part="nbr"/><lit-tag v="pl"/></equal>
                     <equal><clip pos="1" part="nbr"/><lit-tag v="sg"/></equal></and>
              </or></not>
            </and>
          </test>
          <let><clip pos="1" part="art"/><lit-tag v="def"/></let>
        </when>
      </choose>
    </def-macro>

    <!-- Output macros: -->
    <def-macro n="out_det_when_adjlike" npar="2"
               c="arg.1: adj_n or det chunk, arg.2: gives typographic case to adj/det
                  Outputs a space afterwards.">
      <call-macro n="set_det_gender1.n"><with-param pos="1"/></call-macro>
      <choose><when>
        <test><or>
          <begins-with caseless="yes"><clip pos="1" part="lemh"/><lit v="adj"/></begins-with>
          <begins-with caseless="yes"><clip pos="1" part="lemh"/><lit v="needdet_"/></begins-with>
          <begins-with caseless="yes"><clip pos="1" part="tags"/><lit-tag v="det.qnt"/></begins-with>
        </or></test>
        <out>
          <chunk>
            <get-case-from pos="1"><lit v="det"/></get-case-from>
            <lit-tag v="det.dem"/>
            <var n="det_gender"/>
            <var n="number_no_sp"/>
            <lit v="{^"/>
            <get-case-from pos="1"><lit v="den"/></get-case-from>
            <lit-tag v="det.dem"/>
            <var n="det_gender"/>
            <var n="number_no_sp"/>
            <lit v="$}"/>
          </chunk>
          <b/>
        </out>
        <let><clip pos="1" part="lemh"/><get-case-from pos="2"><clip pos="1" part="lemh"/></get-case-from></let>
      </when></choose>
    </def-macro>

    <def-macro n="out_ndef" npar="2"
               c="arg.1: possessed noun, arg.2: gives typographic case
                  Strip case, add definiteness.">
      <call-macro n="get_case_from_detpos">
        <with-param pos="1"/>
        <with-param pos="2"/>
      </call-macro>
      <let><clip pos="1" part="art"/><lit-tag v="def"/></let>
      <out>
        <chunk><clip pos="1" part="whole"/></chunk>
      </out>
    </def-macro>

    <def-macro n="out_sin" npar="1"
               c="arg.1: noun (possessor)">
      <call-macro n="set_det_gender1.n"><with-param pos="1"/></call-macro>
      <out><chunk>
        <lit v="det"/>
        <var n="det_gender"/>
        <var n="number_no_sp"/>
        <lit v="{^sin"/>
        <lit-tag v="det.pos"/>
        <var n="det_gender"/>
        <var n="number_no_sp"/>
        <lit v="$}"/>
      </chunk></out>
    </def-macro>

    <def-macro n="out_bi-gen-prep" npar="2"
               c="arg.1: preposition, arg.2: owned noun">
      <let><var n="genpr"/><clip pos="2" part="gen_prep_override"/></let>
      <choose>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_til"/></equal></test><let><var n="pr_lemh"/><lit v="til"/></let></when>
        <!-- dev/genitive-prepositions: -->
        <when><test><equal><var n="genpr"/><lit-tag v="pr_av"/></equal></test><let><var n="pr_lemh"/><lit v="av"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_blant"/></equal></test><let><var n="pr_lemh"/><lit v="blant"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_etter"/></equal></test><let><var n="pr_lemh"/><lit v="etter"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_for"/></equal></test><let><var n="pr_lemh"/><lit v="for"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_frå"/></equal></test><let><var n="pr_lemh"/><lit v="frå"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_før"/></equal></test><let><var n="pr_lemh"/><lit v="før"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_gjennom"/></equal></test><let><var n="pr_lemh"/><lit v="gjennom"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_hos"/></equal></test><let><var n="pr_lemh"/><lit v="hos"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_i"/></equal></test><let><var n="pr_lemh"/><lit v="i"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_med"/></equal></test><let><var n="pr_lemh"/><lit v="med"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_mellom"/></equal></test><let><var n="pr_lemh"/><lit v="mellom"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_mot"/></equal></test><let><var n="pr_lemh"/><lit v="mot"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_om"/></equal></test><let><var n="pr_lemh"/><lit v="om"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_over"/></equal></test><let><var n="pr_lemh"/><lit v="over"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_per"/></equal></test><let><var n="pr_lemh"/><lit v="per"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_på"/></equal></test><let><var n="pr_lemh"/><lit v="på"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_rundt"/></equal></test><let><var n="pr_lemh"/><lit v="rundt"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_som"/></equal></test><let><var n="pr_lemh"/><lit v="som"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_uansett"/></equal></test><let><var n="pr_lemh"/><lit v="uansett"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_under"/></equal></test><let><var n="pr_lemh"/><lit v="under"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_unna"/></equal></test><let><var n="pr_lemh"/><lit v="unna"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_ut"/></equal></test><let><var n="pr_lemh"/><lit v="ut"/></let></when>
        <when><test><equal><var n="genpr"/><lit-tag v="pr_ved"/></equal></test><let><var n="pr_lemh"/><lit v="ved"/></let></when>

        <otherwise><let><var n="pr_lemh"/><lit v=""/></let></otherwise>
      </choose>
      <choose>
        <when>
          <test><equal><var n="pr_lemh"/><lit v=""/></equal></test>
          <out><chunk><clip pos="1" part="whole"/></chunk></out>
        </when>
        <otherwise>
          <out>
            <chunk>
              <lit v="gen-prep"/>
              <lit-tag v="pr"/>
              <lit v="{^"/>
              <var n="pr_lemh"/>
              <lit-tag v="pr"/>
              <lit v="$}"/>
          </chunk></out>
        </otherwise>
      </choose>
    </def-macro>

  </section-def-macros>


  <section-rules>

    <rule comment="AV_ALLE N: av alle beslag → av alle beslaga">
      <pattern>
        <pattern-item n="av_alle"/>
        <pattern-item n="nind_noadj"/>
        <pattern-item n="pr_OR_vblex"/>
      </pattern>
      <action>
        <let><clip pos="2" part="art"/><lit-tag v="def"/></let>
        <let><clip pos="2" part="nbr"/><lit-tag v="pl.chunknum"/></let>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="NEEDDET_ADJ_N: britiske statsministeren => den britiske statsministeren
                   Needs to be before NDEF rule.">
      <pattern>
        <pattern-item n="needdet_adj_n"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <call-macro n="out_det_when_adjlike"><with-param pos="1"/><with-param pos="1"/></call-macro>
        <let><clip pos="1" part="lemh"/><lit v="adj_n"/></let>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <!-- AUX PART rules -->

    <rule comment="INFM INFAUX ADJPART => INFM INFAUX ADJPART
                   å leses => å bli lest
                   Infinitive passives with an infinitive marker should keep the auxiliary.
                   Overrides below aux-deleting rule below (no infm => no aux needed)">
      <pattern>
        <pattern-item n="infm"/>
        <pattern-item n="infaux"/>
        <pattern-item n="adjpart"/>
      </pattern>
      <action>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="INFM ADV INFAUX => INFM ADV INFAUX ADJPART">
      <pattern>
        <pattern-item n="infm"/>
        <pattern-item n="adv"/>
        <pattern-item n="infaux"/>
        <pattern-item n="adjpart"/>
      </pattern>
      <action>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="INFM ADV ADV INFAUX ADJPART => INFM ADV ADV INFAUX ADJPART">
      <pattern>
        <pattern-item n="infm"/>
        <pattern-item n="adv"/>
        <pattern-item n="adv"/>
        <pattern-item n="infaux"/>
        <pattern-item n="adjpart"/>
      </pattern>
      <action>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <b pos="4"/>
          <chunk>
            <clip pos="5" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <!-- AUXPASS ADJPART ADV* => AUXPASS ADV* ADJPART ADV*
         and AUX ADV* ADJPART => AUX ADV* ADJPART rules -->

    <rule comment="AUX ADJPART => AUX ADJPART">
      <pattern>
        <pattern-item n="aux"/>
        <pattern-item n="adjpart"/>
      </pattern>
      <action>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="AUX PASV-PP PRN_SUBJ => AUX PRN_SUBJ PASV-PP
                   (Videre) påpekes det =1> (Vidare) blir påpeikt det =2> (Vidare) blir det påpeikt">
      <pattern>
        <pattern-item n="aux"/>
        <pattern-item n="pasv-pp"/>
        <pattern-item n="prn_subj"/>
      </pattern>
      <action>
        <call-macro n="modify_prn_gen"><with-param pos="3"/></call-macro>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="AUX PASV-PP PRN_SUBJ ADV_MOVABLE => AUX PRN_SUBJ PASV-PP ADV_MOVABLE
                   (Videre) oppgis det ikke =1> (Vidare) blir oppgitt det ikkje =2> (Vidare) blir det ikkje oppgitt

                   «I en uttalelse på Twitter oppgis det ikke antall drepte eller sårede»">
      <pattern>
        <pattern-item n="aux"/>
        <pattern-item n="pasv-pp"/>
        <pattern-item n="prn_subj"/>
        <pattern-item n="adv_movable"/>
      </pattern>
      <action>
        <call-macro n="modify_prn_gen"><with-param pos="3"/></call-macro>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="AUXPASS ADJPART ADV_MOVABLE => AUXPASS ADV_MOVABLE ADJPART
                   boken leses ofte =1> boka blir lest ofte =2> boka blir ofte lest
                   auxpass are created in t1x; move adv's behind these
                   (No match if the aux was there originally, then we don't move any adverbs)">
      <pattern>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart"/>
        <pattern-item n="adv_movable"/>
      </pattern>
      <action>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="AUXPASS ADJPART LEMQ ADV_MOVABLE => AUXPASS ADV_MOVABLE ADJPART LEMQ
                   påberopes ofte =1> vert skulda på ofte =2> vert ofte skulda på
                   auxpass are created in t1x; move adv's behind these
                   (No match if the aux was there originally, then we don't move any adverbs)">
      <pattern>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart"/>
        <pattern-item n="lemq"/>
        <pattern-item n="adv_movable"/>
      </pattern>
      <action>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="AUXPASS ADJPART ADV_MOVABLE ADV_MOVABLE => AUXPASS ADV_MOVABLE ADV_MOVABLE ADJPART
                   boken leses heller ofte =1> boka blir lest heller ofte =2> boka blir heller ofte lest
                   auxpass are created in t1x; move adv's behind these
                   (No match if the aux was there originally, then we don't move any adverbs)">
      <pattern>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart"/>
        <pattern-item n="adv_movable"/>
        <pattern-item n="adv_movable"/>
      </pattern>
      <action>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="AUXPASS ADJPART LEMQ ADV_MOVABLE ADV_MOVABLE => AUXPASS ADV_MOVABLE ADV_MOVABLE ADJPART LEMQ
                   påberopes heller ofte =1> vert skulda på heller ofte =2> vert heller ofte skulda på
                   auxpass are created in t1x; move adv_movable's behind these
                   (No match if the aux was there originally, then we don't move any adv_movableerbs)">
      <pattern>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart"/>
        <pattern-item n="lemq"/>
        <pattern-item n="adv_movable"/>
        <pattern-item n="adv_movable"/>
      </pattern>
      <action>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="5" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="AUX ADV ADJPART => AUX ADV ADJPART
                   boken ble ofte lest =1> boka vart ofte lesen =2> boka vart ofte lesen">
      <pattern>
        <pattern-item n="aux"/>
        <pattern-item n="adv"/>
        <pattern-item n="adjpart"/>
      </pattern>
      <action>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="3"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="AUX ADV ADV ADJPART => AUX ADV ADV ADJPART
                   boken ble heller ofte lest =1> boka vart heller ofte lesen =2> boka vart heller ofte lesen">
      <pattern>
        <pattern-item n="aux"/>
        <pattern-item n="adv"/>
        <pattern-item n="adv"/>
        <pattern-item n="adjpart"/>
      </pattern>
      <action>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="4"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>



    <rule comment="AUXPASS ADJPART NDEF DETPOS => AUXPASS NDEF DETPOS ADJPART
                   reguleres bøkene dine =1> blir regulert bøkene dine =2> blir bøkene dine regulerte
                   auxpass are created in t1x
                   (No match if the aux was there originally, then we don't move anything)">
      <pattern>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart_np_movable"/>
        <pattern-item n="ndef"/>
        <pattern-item n="detpos"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="AUXPASS ADJPART NDEF => AUXPASS NDEF ADJPART
                   (nå) reguleres bøkene =1> blir regulert bøkene =2> blir bøkene regulert
                   auxpass are created in t1x
                   (No match if the aux was there originally, then we don't move anything)">
      <pattern>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart_np_movable"/>
        <pattern-item n="ndef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="AUXPASS ADJPART_NP_MOVABLE DET NDEF => AUXPASS DET NDEF ADJPART_NP_MOVABLE
                   (nå) reguleres de sentrale bøkene =1> blir regulert de sentrale bøkene =2> blir de sentrale bøkene regulert
                   auxpass are created in t1x
                   (No match if the aux was there originally, then we don't move anything)">
      <!-- We need actual syntactical tagging to fix this in general: -->
      <!-- TODO: not for «denne veka/hausten», «(På) fredag», «(Ifølge) Nationen» -->
      <!-- TODO: not for MWE-verbs, not for «tildeles» -->
      <!-- TODO: not for inverted order (tildeles): 235765 Årets Peer Gynt-pris blir tildelt den nettbaserte TV-serien tildelt «Skam» og regissør Julie Andem. -->
      <!-- TODO: «denne typen<n> verktøy<n>» as one chunk? -->
      <pattern>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart_np_movable"/>
        <pattern-item n="det"/>
        <pattern-item n="ndef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="N AUXPASS ADJPART NDEF => N AUXPASS ADJPART NDEF
                   Overrides the AUXPASS ADJPART NDEF rule.
                   kroner øremerkes tiltaket =1> kroner blir øremerket tiltaket =2> kroner blir øremerket tiltaket
                   auxpass are created in t1x
                   (No match if the aux was there originally, then we don't move anything)">
      <pattern>
        <pattern-item n="nom"/>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart"/>
        <pattern-item n="ndef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="3"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="N AUXPASS ADJPART DET NDEF => N AUXPASS ADJPART DET NDEF
                   Overrides the AUXPASS ADJPART DET NDEF rule.
                   (mens) avstemningen holdes den påfølgende onsdagen → (mens) avstemminga blir halden den følgjande onsdagen
                   auxpass are created in t1x
                   (No match if the aux was there originally, then we don't move anything)">
      <pattern>
        <pattern-item n="nom"/>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart"/>
        <pattern-item n="det"/>
        <pattern-item n="ndef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <call-macro n="set_ana"><with-param pos="2"/></call-macro>
        <call-macro n="set_ana"><with-param pos="5"/></call-macro>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="3"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <b pos="4"/>
          <chunk>
            <clip pos="5" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="PREP N AUXPASS ADJPART_NP_MOVABLE NDEF => PREP N AUXPASS ADJPART_NP_MOVABLE NDEF
                   Overrides the rules overriding AUXPASS ADJPART NDEF rules.
                   etter fremleggelsen beskyldes regjeringen =1> etter fremleggelsen blir regjeringen skulda =2> etter framlegginga blir regjeringen skulda
                   auxpass are created in t1x
                   (No match if the aux was there originally, then we don't move anything)">
      <pattern>
        <pattern-item n="prep"/>
        <pattern-item n="nom"/>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart_np_movable"/>
        <pattern-item n="ndef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <call-macro n="set_ana"><with-param pos="5"/></call-macro>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="4"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="5" part="whole"/>
          </chunk>
          <b pos="4"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="PREP N AUXPASS ADJPART_NP_MOVABLE DET NDEF => PREP N AUXPASS DET NDEF ADJPART_NP_MOVABLE
                   Overrides the rules overriding AUXPASS ADJPART DET NDEF rules">
      <pattern>
        <pattern-item n="prep"/>
        <pattern-item n="nom"/>
        <pattern-item n="auxpass"/>
        <pattern-item n="adjpart_np_movable"/>
        <pattern-item n="det"/>
        <pattern-item n="ndef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <call-macro n="set_ana"><with-param pos="6"/></call-macro>
        <call-macro n="modify_pp_gen_nbr"><with-param pos="4"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b pos="3"/>
          <chunk>
            <clip pos="5" part="whole"/>
          </chunk>
          <b pos="4"/>
          <chunk>
            <clip pos="6" part="whole"/>
          </chunk>
          <b pos="5"/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="VBLEX => VBLEX">
      <pattern>
        <pattern-item n="vblex"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="VBLEX LEMQ => VBLEX LEMQ
                   Don't output a space since lemq carries a space inside the chunk">
      <pattern>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="VBLEX LEMQ ADV_MOVABLE => VBLEX ADV_MOVABLE LEMQ
                   Push blanks one place up since lemq space is inside the chunk.">
      <pattern>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq"/>
        <pattern-item n="adv_movable"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="VBLEX LEMQ ADV_MOVABLE ADV_MOVABLE => VBLEX ADV_MOVABLE ADV_MOVABLE LEMQ
                   Push blanks one place up since lemq space is inside the chunk.">
      <pattern>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq"/>
        <pattern-item n="adv_movable"/>
        <pattern-item n="adv_movable"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="VBLEX LEMQ NDEF NDEF => VBLEX NDEF LEMQ NDEF
                   Push blanks one place up since lemq space is inside the chunk.">
      <pattern>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq"/>
        <pattern-item n="ndef"/>
        <pattern-item n="ndef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="VBLEX LEMQ PRN_NOM => VBLEX PRN_NOM LEMQ
                   Push blanks one place up since lemq space is inside the chunk.">
      <pattern>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq"/>
        <pattern-item n="prn_nom"/>
      </pattern>
      <action>
        <call-macro n="modify_prn_gen"><with-param pos="3"/></call-macro>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="VBLEX LEMQ PRN_NOM ADV_MOVABLE => VBLEX PRN_NOM ADV_MOVABLE LEMQ
                   Push blanks one place up since lemq space is inside the chunk.
                   [Da] fortsatte hun like_godt [karrieren] → heldt ho fram like godt → heldt ho like godt fram">
      <pattern>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq"/>
        <pattern-item n="prn_nom"/>
        <pattern-item n="adv_movable"/>
      </pattern>
      <action>
        <call-macro n="modify_prn_gen"><with-param pos="3"/></call-macro>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b/>
          <chunk><clip pos="4" part="whole"/></chunk>
          <chunk><clip pos="2" part="whole"/></chunk>
        </out>
      </action>
    </rule>
    <rule comment="VBLEX LEMQ PRN_NOM ADV_MOVABLE ADV_MOVABLE => VBLEX PRN_NOM ADV_MOVABLE ADV_MOVABLE LEMQ
                   Push blanks one place up since lemq space is inside the chunk.
                   [Derfor] fraråder vi nå klart [å] → rår mot vi no klart → rår vi no klart mot">
      <pattern>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq"/>
        <pattern-item n="prn_nom"/>
        <pattern-item n="adv_movable"/>
        <pattern-item n="adv_movable"/>
      </pattern>
      <action>
        <call-macro n="modify_prn_gen"><with-param pos="3"/></call-macro>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="4" part="whole"/></chunk>
          <b pos="4"/>
          <chunk><clip pos="5" part="whole"/></chunk>
          <chunk><clip pos="2" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="VBLEX LEMQ PRN_ACC ADV_MOVABLE => VBLEX PRN_ACC ADV_MOVABLE LEMQ
                   Push blanks one place up since lemq space is inside the chunk.
                   [men] utelukker det ikke → ser bort frå det ikkje → ser ikkje bort frå det">
      <pattern>
        <pattern-item n="vblex"/> <!-- 1. ser -->
        <pattern-item n="lemq"/>  <!-- 2. bort frå -->
        <pattern-item n="prn_acc"/> <!-- 3. det -->
        <pattern-item n="adv_movable"/> <!-- 4. ikkje -->
      </pattern>
      <action>
        <call-macro n="modify_prn_gen"><with-param pos="3"/></call-macro>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b/>
          <chunk><clip pos="4" part="whole"/></chunk>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="ADV VBLEX LEMQ PRN_NOM => ADV VBLEX PRN_NOM LEMQ
                   Push blanks one place up since lemq space is inside the chunk.
                   da oppga han → då gav opp han → då gav han opp">
      <pattern>
        <pattern-item n="adv_movable"/>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq"/>
        <pattern-item n="prn_nom"/>
      </pattern>
      <action>
        <call-macro n="modify_prn_gen"><with-param pos="4"/></call-macro>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b/>
          <chunk><clip pos="4" part="whole"/></chunk>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="NP_PRNNOM_OG VBLEX LEMQ-SKIP-N NDEF => NP_PRNNOM_OG VBLEX LEMQ-SKIP-N NDEF
                   Override below rule
                   We want: Carlsen heldt fram sigersrekka, not *Carlsen heldt sigersrekka fram">
      <pattern>
        <pattern-item n="np_prnnom_og"/>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq-skip-n"/>
        <pattern-item n="ndef"/>
      </pattern>
      <action>
        <call-macro n="modify_prn_gen"><with-param pos="1"/></call-macro>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="VBLEX LEMQ-SKIP-N NDEF_NP_PERS => VBLEX NDEF_NP_PERS LEMQ-SKIP-N
                   Push blanks one place up since lemq space is inside the chunk.
                   - Søndag fortsatte kamphandlingene → Søndag heldt kamphandlingane fram
                   , fortsatte Ola → , heldt Ola fram">
      <pattern>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq-skip-n"/>
        <pattern-item n="ndef_OR_np_pers"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="VBLEX LEMQ-SKIP-N NP_PERS NP_PERS => VBLEX NP_PERS NP_PERS LEMQ-SKIP-N
                   Push blanks one place up since lemq space is inside the chunk.
                   , fortsatte Ola Hansen → , heldt Ola Hansen fram">
      <pattern>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq-skip-n"/>
        <pattern-item n="np_pers"/>
        <pattern-item n="np_nonorg"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="VBLEX LEMQ-SKIP-N NP_PERS NP_PERS NP_PERS => VBLEX NP_PERS NP_PERS NP_PERS LEMQ-SKIP-N
                   Push blanks one place up since lemq space is inside the chunk.
                   , fortsatte Ole Andre Hansen → , heldt Ole Andre Hansen fram">
      <pattern>
        <pattern-item n="vblex"/>
        <pattern-item n="lemq-skip-n"/>
        <pattern-item n="np_pers"/>
        <pattern-item n="np_nonorg"/>
        <pattern-item n="np_nonorg"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="4" part="whole"/>
          </chunk>
          <b/>
          <chunk>
            <clip pos="5" part="whole"/>
          </chunk>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>


    <!-- Possessive noun phrases -->


    <!-- The regular possessive noun phrases, with more complex
         transfer operations.-->
    <rule comment="PREP_GEN NGEN: [til] mannens => mannen sin
                   Very heuristic fallback rule.
                   If we can't match with the below rules, turn the
                   genitive -s into 'sin' garpegenitiv instead.
                   (Removing the prep_gen from t1x)
                   A bit more fluent where eg. input is incomplete:
                         mannens *sykkel => mannen sin *sykkel
                   But we don't know gen/nbr of object, so we could end
                   up with
                         mannens *sykler => mannen sin *sykler
                   So let's just hope plurals possess plurals etc...">
      <pattern>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngen"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="2"/></call-macro>
        <let><clip pos="2" part="a_casedrop"/><lit v=""/></let>
        <let><clip pos="2" part="a_defdrop"/><lit v=""/></let>
        <choose><when>
          <test><not><equal><b pos="1"/><lit v=" "/></equal></not></test>
          <out><b pos="1"/></out>
        </when></choose>
        <out>
          <chunk>
          <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="PREP_GEN DET: [til] det => det sin
                   Fallback, like above">
      <pattern>
        <pattern-item n="prep_gen"/>
        <pattern-item n="det"/>
      </pattern>
      <action>
        <out>
          <chunk>
          <clip pos="2" part="whole"/>
          </chunk>
          <b pos="1"/>
        </out>
        <call-macro n="out_sin"><with-param pos="2"/></call-macro>
        <!-- TODO: keep case instead? ie. strip the casedrop -->
      </action>
    </rule>
    <rule comment="DETNONPOS PREP_GEN NGEN: det [til] forfatterskapets => den forfattarskapen sin">
      <pattern>
        <pattern-item n="detnonpos"/>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngen"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <let><clip pos="3" part="a_casedrop"/><lit v=""/></let>
        <let><clip pos="3" part="a_defdrop"/><lit v=""/></let>
        <choose><when>
          <test><not><equal><b pos="1"/><lit v=" "/></equal></not></test>
          <out><b pos="2"/></out>
        </when></choose>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="3" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="NDEF: (lille) mennesket => (vesle) mennesket
                   Used to output a determiner with out_det_when_adj, but this lead to
                   some odd problems.">
      <pattern>
        <pattern-item n="ndef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <call-macro n="modify_case_detpos"><with-param pos="1"/><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="PREP_GEN NGEN NKEEPGENX: (for) hovedindeksens del → til hovudindeksen del → hovedindeksens del
                   Override below prep-moving rules.">
      <pattern>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngen"/>
        <pattern-item n="nkeepgenx"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <let><clip pos="2" part="a_casedrop"/><lit v=""/></let>
        <let><clip pos="3" part="a_keepgenx"/><lit v=""/></let>
        <choose><when>
          <test><not><equal><b pos="1"/><lit v=" "/></equal></not></test>
          <out><b pos="1"/></out>
        </when></choose>
        <out>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="PREP_GEN NGEN NIND: naboens bil => bilen til naboen
                              naboens røde bil => den røde bilen til naboen
                   nind makes sure we don't match 'min Per(np)' nor 'min bils(gen)'">
      <pattern>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngen"/>
        <pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <call-macro n="switch_cases"><with-param pos="3"/><with-param pos="2"/></call-macro>

        <call-macro n="out_det_when_adjlike"><with-param pos="3"/><with-param pos="2"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="3"/><with-param pos="2"/></call-macro>
        <out><b pos="1"/></out>
        <call-macro n="out_bi-gen-prep"><with-param pos="1"/><with-param pos="3"/></call-macro>
        <out><b pos="2"/><chunk><clip pos="2" part="whole"/></chunk></out>
      </action>
    </rule>

    <rule comment="UNKNOWN sin NIND: *alfdj sin måte => *alfdj sin måte
                   Override the below rule">
      <pattern>
        <pattern-item n="unknown"/>
        <pattern-item n="sin"/>
        <pattern-item n="nind"/>
      </pattern>
      <action>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>
    <rule comment="detpos_keep NIND: mot sin vilje => mot sin vilje
                   Override the below rule">
      <pattern>
        <pattern-item n="detpos_keep"/>
        <pattern-item n="nind"/>
      </pattern>
      <action>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
        </out>
      </action>
    </rule>
    <rule comment="DETPOS NIND_NOGEN: min mor => mora mi
                                      ditt hus => huset ditt
                   nind_nogen makes sure we don't match 'min Per(np)' nor 'min bils(gen)' or 'våre dyrs beste'
                   Second example shows how determiners ..um..determine number.">
      <pattern>
        <pattern-item n="detpos"/>
        <pattern-item n="nind_nogen"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="2"/></call-macro>
        <call-macro n="switch_cases"><with-param pos="2"/><with-param pos="1"/></call-macro>

        <call-macro n="out_det_when_adjlike"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="2"/><with-param pos="1"/></call-macro>

        <call-macro n="modify_det_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <out>
          <b pos="1"/>
          <chunk><clip pos="1" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DETSAMTLIGE NIND_NOGEN: samtlige røde hus → alle dei raude husa
                                           samtlige hus → alle hus">
      <pattern>
        <pattern-item n="detsamtlige_def"/>
        <pattern-item n="nind_nogen"/>
      </pattern>
      <action>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
        </out>
        <choose>
          <when>
            <test><begins-with><clip pos="2" part="lem"/><lit v="NO"/></begins-with>
            </test>
            <call-macro n="set_ana"><with-param pos="2"/></call-macro>
            <out><chunk><clip pos="2" part="whole"/></chunk></out>
          </when>
          <otherwise>
            <call-macro n="set_ana"><with-param pos="2"/></call-macro>
            <call-macro n="out_det_when_adjlike"><with-param pos="2"/><with-param pos="2"/></call-macro>
            <call-macro n="out_ndef"><with-param pos="2"/><with-param pos="2"/></call-macro>
          </otherwise>
        </choose>
      </action>
    </rule>
    <rule comment="DETSAMTLIGE DETQNTUNPL NIND_NOGEN: samtlige 90 hus → alle dei 90 husa">
      <pattern>
        <pattern-item n="detsamtlige_def"/>
        <pattern-item n="detqntunpl"/>
        <pattern-item n="nind_nogen"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <call-macro n="modify_det_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
        </out>
        <call-macro n="out_det_when_adjlike"><with-param pos="2"/><with-param pos="3"/></call-macro>
        <out>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
        </out>
        <call-macro n="out_ndef"><with-param pos="3"/><with-param pos="3"/></call-macro>
      </action>
    </rule>
    <rule comment="DETSAMTLIGE NGEN NIND_NOGEN: samtlige av landets hus → alle i landet hus → alle husa i landet">
      <pattern>
        <pattern-item n="detsamtlige_def"/>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngen"/>
        <pattern-item n="nind_nogen"/>
      </pattern>
      <action>
        <let><clip pos="4" part="nbr"/><lit-tag v="pl"/></let>
        <let><clip pos="4" part="tags"/><concat><clip pos="4" part="tags"/><lit-tag v="chunknum"/></concat></let>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <call-macro n="modify_det_gender2.n.det"><with-param pos="3"/><with-param pos="1"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
        </out>
        <call-macro n="out_det_when_adjlike"><with-param pos="4"/><with-param pos="2"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="4"/><with-param pos="2"/></call-macro>
        <out>
          <b pos="2"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>


    <rule comment="PREP_GEN NGEN PREP_GEN NGEN NIND: [på] kjøkkenets [til] katts snute => snuten til katten på kjøkkenet">
      <pattern>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngen"/>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngen"/>
	<pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="5"/></call-macro>
        <call-macro n="switch_cases"><with-param pos="5"/><with-param pos="2"/></call-macro>

        <call-macro n="out_det_when_adjlike"><with-param pos="5"/><with-param pos="1"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="5"/><with-param pos="2"/></call-macro>

        <out><b pos="1"/></out>
        <call-macro n="out_bi-gen-prep"><with-param pos="3"/><with-param pos="5"/></call-macro> <!-- 5=_snuten_ til katten -->
        <out><b pos="2"/></out>
        <call-macro n="out_det_when_adjlike"><with-param pos="4"/><with-param pos="4"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="4"/><with-param pos="4"/></call-macro>
        <out><b pos="3"/></out>
        <call-macro n="out_bi-gen-prep"><with-param pos="1"/><with-param pos="4"/></call-macro> <!-- 4=_katten_ på kjøkkenet -->
        <out><b pos="4"/></out>
        <call-macro n="out_det_when_adjlike"><with-param pos="2"/><with-param pos="2"/></call-macro>
        <out><chunk><clip pos="2" part="whole"/></chunk></out>
      </action>
    </rule>
    <rule comment="DETPOS PREP_GEN NGEN NIND: min [til] katts snute => snuten til katten min
                                     (but not *'min din snute')">
      <pattern>
	<pattern-item n="detpos"/>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngen"/>
	<pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <call-macro n="switch_cases"><with-param pos="4"/><with-param pos="1"/></call-macro>

        <call-macro n="out_det_when_adjlike"><with-param pos="4"/><with-param pos="1"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="4"/><with-param pos="1"/></call-macro>

        <out><b pos="1"/></out>
        <call-macro n="out_bi-gen-prep"><with-param pos="2"/><with-param pos="4"/></call-macro> <!-- 4=_snuten_ til katten -->
        <out><b pos="2"/></out>
        <call-macro n="out_det_when_adjlike"><with-param pos="3"/><with-param pos="3"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="3"/><with-param pos="3"/></call-macro>

        <call-macro n="modify_det_gender2.n.det"><with-param pos="3"/><with-param pos="1"/></call-macro>
        <out>
          <b pos="3"/>
          <chunk><clip pos="1" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="PREP_GEN NGEN DETNONPOS NIND:
                   toppens mange hunder =1> på toppen mange hunder =2> dei mange hundane på toppen
                   nind makes sure we don't match 'min Per(np)' nor 'min bils(gen)'">
      <pattern>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngen"/>
        <pattern-item n="detnonpos"/>
        <pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <call-macro n="switch_cases"><with-param pos="3"/><with-param pos="2"/></call-macro>

        <call-macro n="out_det_when_adjlike"><with-param pos="3"/><with-param pos="2"/></call-macro>
        <out>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="1"/>
        </out>
        <call-macro n="out_ndef"><with-param pos="4"/><with-param pos="4"/></call-macro>
        <out><b pos="2"/></out>
        <call-macro n="out_bi-gen-prep"><with-param pos="1"/><with-param pos="4"/></call-macro> <!-- 4=_hundane_ på toppen -->
        <out><b pos="3"/></out>
        <out><chunk><clip pos="2" part="whole"/></chunk></out>
      </action>
    </rule>
    <rule comment="sin DETEMPH PREP_GEN NGEN NIND: sin egen administrasjons innsats → innsatsen til sin egen administrasjon">
      <pattern>
        <pattern-item n="sin"/>
        <pattern-item n="detemph"/>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngen"/>
        <pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="5"/></call-macro>
        <call-macro n="switch_cases"><with-param pos="5"/><with-param pos="1"/></call-macro>
        <call-macro n="out_det_when_adjlike"><with-param pos="5"/><with-param pos="1"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="5"/><with-param pos="1"/></call-macro>

        <call-macro n="modify_det_gender2.n.det"><with-param pos="4"/><with-param pos="1"/></call-macro>
        <call-macro n="modify_det_gender2.n.det"><with-param pos="4"/><with-param pos="2"/></call-macro>
        <out>
          <b pos="1"/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="4"/>
          <chunk><clip pos="4" part="whole"/></chunk>
        </out>
      </action>
    </rule>
    <rule comment="DETALL PREP_GEN NGENSGDEF NPLIND: alle [til] kommunen idrettslag => alle [dei] idrettslaga til kommunen">
      <pattern>
	<pattern-item n="detall"/>
	<pattern-item n="prep_gen"/>
	<pattern-item n="ngensgdef"/>
	<pattern-item n="nplind"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
        </out>
        <call-macro n="out_det_when_adjlike"><with-param pos="4"/><with-param pos="2"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="4"/><with-param pos="4"/></call-macro>
        <out>
          <b pos="2"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>
    <rule comment="DETQNTPL PREP_GEN NGENSGDEF NPLIND: mange [til] kommunen idrettslag => [dei] mange idrettslaga til kommunen
                   As above rule, but opposite order of out_det_when_adjlike and detqntpl">
      <pattern>
	<pattern-item n="detqntpl"/>
	<pattern-item n="prep_gen"/>
	<pattern-item n="ngensgdef"/>
	<pattern-item n="nplind"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <call-macro n="out_det_when_adjlike"><with-param pos="4"/><with-param pos="1"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
        </out>
        <call-macro n="out_ndef"><with-param pos="4"/><with-param pos="4"/></call-macro>
        <out>
          <b pos="2"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>
    <rule comment="DETNONPOS PREP_GEN NGEN NIND: en [til] katts snute => snuten til ein katt">
      <pattern>
	<pattern-item n="detnonpos"/>
	<pattern-item n="prep_gen"/>
	<pattern-item n="ngen"/>
	<pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <call-macro n="switch_cases"><with-param pos="4"/><with-param pos="1"/></call-macro>
        <call-macro n="out_det_when_adjlike"><with-param pos="4"/><with-param pos="1"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="4"/><with-param pos="1"/></call-macro>

        <call-macro n="modify_det_gender2.n.det"><with-param pos="3"/><with-param pos="1"/></call-macro>
        <out>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>
    <rule comment="DETNONPOS DETNONPOS PREP_GEN NGEN NIND: den forrige [til] Lamaens bil => bilen til den forrige Lamaen">
      <pattern>
	<pattern-item n="detnonpos"/>
	<pattern-item n="detnonpos"/>
	<pattern-item n="prep_gen"/>
	<pattern-item n="ngen"/>
	<pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="5"/></call-macro>
        <call-macro n="switch_cases"><with-param pos="5"/><with-param pos="1"/></call-macro>

        <call-macro n="out_det_when_adjlike"><with-param pos="5"/><with-param pos="1"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="5"/><with-param pos="1"/></call-macro>

        <call-macro n="modify_det_gender2.n.det"><with-param pos="4"/><with-param pos="1"/></call-macro>
        <call-macro n="modify_det_gender2.n.det"><with-param pos="4"/><with-param pos="2"/></call-macro>
        <out>
          <b pos="1"/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="4"/>
          <chunk><clip pos="4" part="whole"/></chunk>
        </out>
      </action>
    </rule>


    <rule comment="PREP_GEN NGENDEForPL NIND PREP_NHEAD
                   næringslivets tillit til de rådende myndigheter → til næringslivet tillita de rådende myndigheter → tillita næringslivet har til dei rådande styresmaktene
                   drop the prep_gen from t1x and rewrite with «har»">
      <pattern>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngendefORpl"/>
        <pattern-item n="nind"/>
        <pattern-item n="prep_nhead"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="2"/></call-macro>
        <call-macro n="switch_cases"><with-param pos="3"/><with-param pos="2"/></call-macro>

        <call-macro n="out_det_when_adjlike"><with-param pos="3"/><with-param pos="2"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="3"/><with-param pos="1"/></call-macro>
        <out>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk>
            <lit v="vblex"/>
            <lit-tag v="vblex"/>
            <var n="ana_temps"/>
            <lit v="{^ha"/>
            <lit-tag v="vblex"/>
            <var n="ana_temps"/>
            <lit v="$}"/>
          </chunk>
          <b pos="3"/>
          <chunk><clip pos="4" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="PREP_GEN NGENDEForPL DETNONPOS NIND PREP_NHEAD
                   senterets 13 millioner i → til senteret 13 millioner i → de 13 millioner senteret har
                   drop the prep_gen from t1x and rewrite with «har»">
      <pattern>
        <pattern-item n="prep_gen"/>
        <pattern-item n="ngendefORpl"/>
        <pattern-item n="detnonpos"/>
        <pattern-item n="nind"/>
        <pattern-item n="prep_nhead"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="2"/></call-macro>
        <call-macro n="switch_cases"><with-param pos="3"/><with-param pos="2"/></call-macro>

        <call-macro n="out_det_when_adjlike"><with-param pos="3"/><with-param pos="2"/></call-macro>
        <out>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="1"/>
        </out>
        <call-macro n="out_ndef"><with-param pos="4"/><with-param pos="1"/></call-macro>
        <out>
          <b pos="2"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="3"/>
          <chunk>
            <lit v="vblex"/>
            <lit-tag v="vblex"/>
            <var n="ana_temps"/>
            <lit v="{^ha"/>
            <lit-tag v="vblex"/>
            <var n="ana_temps"/>
            <lit v="$}"/>
          </chunk>
          <b pos="4"/>
          <chunk><clip pos="5" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="NDEF DETPOS: jenten min => jenta mi">
      <pattern>
        <pattern-item n="ndef"/>
        <pattern-item n="detpos"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <call-macro n="modify_det_gender2.n.det"><with-param pos="1"/><with-param pos="2"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DETENHVER NOM: enhver sak → alle sak → alle saker
                   (Override general DET NOM rule)">
      <pattern>
        <pattern-item n="detenhver"/>
        <pattern-item n="nom_advnom"/>
      </pattern>
      <action>
        <let><clip pos="2" part="nbr"/><clip pos="1" part="nbr"/></let>
        <let><clip pos="2" part="tags"/><concat><clip pos="2" part="tags"/><lit-tag v="chunknum"/></concat></let>
        <call-macro n="modify_det_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <choose><when c="only set ana based on det if no ana, or if n is def">
          <test><or>
            <equal><var n="ana_nbr"/><lit v=""/></equal>
            <equal><clip pos="2" part="art"/><lit-tag v="def"/></equal>
          </or></test>
          <call-macro n="set_ana"><with-param pos="2"/></call-macro>
        </when></choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
        </out>
      </action>
    </rule>
    <rule comment="DETENHVER NOM AUX ADJSG: enhver aksjon er uakseptabel → alle sak er uakseptabel → alle saker er uakseptable">
      <pattern>
        <pattern-item n="detenhver"/>
        <pattern-item n="nom_advnom"/>
        <pattern-item n="aux"/>
        <pattern-item n="adjsg"/>
      </pattern>
      <action>
        <let><clip pos="2" part="nbr"/><clip pos="1" part="nbr"/></let>
        <let><clip pos="2" part="tags"/><concat><clip pos="2" part="tags"/><lit-tag v="chunknum"/></concat></let>
        <call-macro n="modify_det_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <choose><when c="only set ana based on det if no ana, or if n is def">
          <test><or>
            <equal><var n="ana_nbr"/><lit v=""/></equal>
            <equal><clip pos="2" part="art"/><lit-tag v="def"/></equal>
          </or></test>
          <call-macro n="set_ana"><with-param pos="2"/></call-macro>
        </when></choose>

        <let><clip pos="4" part="nbr"/><clip pos="1" part="nbr"/></let>
        <let><clip pos="4" part="tags"/><concat><clip pos="4" part="tags"/><lit-tag v="chunknum"/></concat></let>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="4" part="whole"/></chunk>
        </out>
      </action>
    </rule>
    <rule comment="DETENHVER NOM AUX ADJSG: enhver aksjon vil være uakseptabel → alle sak vil vere uakseptabel → alle saker vil vere uakseptable">
      <pattern>
        <pattern-item n="detenhver"/>
        <pattern-item n="nom_advnom"/>
        <pattern-item n="aux"/>
        <pattern-item n="aux"/>
        <pattern-item n="adjsg"/>
      </pattern>
      <action>
        <let><clip pos="2" part="nbr"/><clip pos="1" part="nbr"/></let>
        <let><clip pos="2" part="tags"/><concat><clip pos="2" part="tags"/><lit-tag v="chunknum"/></concat></let>
        <call-macro n="modify_det_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <choose><when c="only set ana based on det if no ana, or if n is def">
          <test><or>
            <equal><var n="ana_nbr"/><lit v=""/></equal>
            <equal><clip pos="2" part="art"/><lit-tag v="def"/></equal>
          </or></test>
          <call-macro n="set_ana"><with-param pos="2"/></call-macro>
        </when></choose>

        <let><clip pos="5" part="nbr"/><clip pos="1" part="nbr"/></let>
        <let><clip pos="5" part="tags"/><concat><clip pos="5" part="tags"/><lit-tag v="chunknum"/></concat></let>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="4" part="whole"/></chunk>
          <b pos="4"/>
          <chunk><clip pos="5" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET NOM: en kvinne => ei kvinne
		            hvilken jente => kva for ei jente
			    egne hus => eigne hus
			    et Norge => eit Noreg
                            dette hus => dette huset
	           np får ikkje noko tal i den siste.">
      <pattern>
        <pattern-item n="det"/>
        <pattern-item n="nom"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="2"/></call-macro>
        <choose>
          <when c="don't change gender for '(er) dette kjernen' etc.
                   and don't use gender from first part of split compounds:
                   «Den(m) narkotika-(nt) [og korrupsjonsdømte politimannen(m)]">
            <test><or>
              <and>
                <equal><clip pos="1" part="gen"/><lit-tag v="nt"/></equal>
                <not><equal><clip pos="2" part="sl-gen"/><lit-tag v="sl-nt"/></equal></not>
              </and>
              <not><equal><clip pos="2" part="a_cmp"/><lit v=""/></equal></not>
            </or></test>
            <!-- TODO: reject-current-rule in interchunk -->
            <!-- <reject-current-rule shifting="no"/> -->
          </when>
          <otherwise>
            <call-macro n="modify_det_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
            <call-macro n="set_n_defness"><with-param pos="2"/><with-param pos="1"/></call-macro>
          </otherwise>
        </choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET ADVLADJ ANOM_DEF: det sterkt høyreorienterte nettstedet → den sterkt høgreorienterte nettstaden">
      <pattern>
        <pattern-item n="det"/>
        <pattern-item n="advladj"/>
        <pattern-item n="anom_def"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <choose>
          <when c="don't change gender for '(er) dette kjernen' etc.">
            <test><and>
              <equal><clip pos="1" part="gen"/><lit-tag v="nt"/></equal>
              <not><equal><clip pos="3" part="sl-gen"/><lit-tag v="sl-nt"/></equal></not>
            </and></test>
            <!-- TODO: reject-current-rule in interchunk -->
            <!-- <reject-current-rule shifting="no"/> -->
          </when>
          <otherwise>
            <!-- pos=2 is adverbial, so no gender change -->
            <call-macro n="modify_det_gender2.n.det"><with-param pos="3"/><with-param pos="1"/></call-macro>
            <call-macro n="set_n_defness"><with-param pos="3"/><with-param pos="1"/></call-macro>
          </otherwise>
        </choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET NCMPSPLIT CNJCOO ANOM_DEF: den narkotika- og korrupsjonstiltalte mannen">
      <pattern>
        <pattern-item n="det"/>
        <pattern-item n="ncmpsplit"/>
        <pattern-item n="cnjcoo"/>
        <pattern-item n="anom_def"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <call-macro n="modify_det_gender2.n.det"><with-param pos="4"/><with-param pos="1"/></call-macro>
        <call-macro n="set_n_defness"><with-param pos="4"/><with-param pos="1"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="4" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET DETDEMDEF NOM: det samme nettstedet → den same nettstaden">
      <pattern>
        <pattern-item n="det"/>
        <pattern-item n="detdemdef"/>
        <pattern-item n="nom"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <choose>
          <when c="don't change gender for '(er) dette kjernen' etc.">
            <test><and>
              <equal><clip pos="1" part="gen"/><lit-tag v="nt"/></equal>
              <not><equal><clip pos="3" part="sl-gen"/><lit-tag v="sl-nt"/></equal></not>
            </and></test>
            <!-- TODO: reject-current-rule in interchunk -->
            <!-- <reject-current-rule shifting="no"/> -->
          </when>
          <otherwise>
            <!-- pos=2 needs no gender change -->
            <call-macro n="modify_det_gender2.n.det"><with-param pos="3"/><with-param pos="1"/></call-macro>
            <call-macro n="set_n_defness"><with-param pos="3"/><with-param pos="1"/></call-macro>
          </otherwise>
        </choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DETITG DETQNT PREP_SOM ADV NOM: et hvilket som helst norsk hjem → ein kva som helst norsk heim
                   Agree gender.">
      <pattern>
        <pattern-item n="detqnt"/>
        <pattern-item n="detitg"/>
        <pattern-item n="prep_som"/>
        <pattern-item n="adv"/>
        <pattern-item n="nom"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="5"/></call-macro>
        <choose>
          <when c="don't change gender for '(er) dette kjernen' etc.">
            <test><and>
              <equal><clip pos="1" part="gen"/><lit-tag v="nt"/></equal>
              <not><equal><clip pos="5" part="sl-gen"/><lit-tag v="sl-nt"/></equal></not>
            </and></test>
            <!-- TODO: reject-current-rule in interchunk -->
            <!-- <reject-current-rule shifting="no"/> -->
          </when>
          <otherwise>
            <call-macro n="modify_det_gender2.n.det"><with-param pos="5"/><with-param pos="2"/></call-macro>
            <call-macro n="set_n_defness"><with-param pos="5"/><with-param pos="2"/></call-macro>
            <call-macro n="modify_det_gender2.n.det"><with-param pos="5"/><with-param pos="1"/></call-macro>
            <call-macro n="set_n_defness"><with-param pos="5"/><with-param pos="1"/></call-macro>
          </otherwise>
        </choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="4" part="whole"/></chunk>
          <b pos="4"/>
          <chunk><clip pos="5" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DETITG PR_AV NOM: hvilken av de to utleveringsbegjæringene → kva for eit av dei to utleveringskrava">
      <pattern>
        <pattern-item n="detitg"/>  <!--1-->
        <pattern-item n="prep_av"/> <!--2-->
        <pattern-item n="detdem"/>  <!--3-->
        <pattern-item n="detqnt"/>  <!--4-->
        <pattern-item n="nom"/>     <!--5-->
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="5"/></call-macro>
        <choose>
          <when c="don't change gender for '(er) dette kjernen' etc.">
            <test><and>
              <equal><clip pos="1" part="gen"/><lit-tag v="nt"/></equal>
              <not><equal><clip pos="5" part="sl-gen"/><lit-tag v="sl-nt"/></equal></not>
            </and></test>
            <!-- TODO: reject-current-rule in interchunk -->
            <!-- <reject-current-rule shifting="no"/> -->
          </when>
          <otherwise>
            <call-macro n="modify_det_gender2.n.det"><with-param pos="5"/><with-param pos="1"/></call-macro>
            <call-macro n="set_n_defness"><with-param pos="5"/><with-param pos="1"/></call-macro>
          </otherwise>
        </choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="4" part="whole"/></chunk>
          <b pos="4"/>
          <chunk><clip pos="5" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET2ADJ NOM: (som) en hvilken som helst annen sak → (som) alle andre sak → (som) alle andre saker">
      <pattern>
        <pattern-item n="det2adj"/>
        <pattern-item n="nom_advnom"/>
      </pattern>
      <action>
        <let><clip pos="2" part="nbr"/><clip pos="1" part="nbr"/></let>
        <let><clip pos="2" part="tags"/><concat><clip pos="2" part="tags"/><lit-tag v="chunknum"/></concat></let>
        <call-macro n="modify_det_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <choose><when c="only set ana based on det if no ana, or if n is def">
          <test><or>
            <equal><var n="ana_nbr"/><lit v=""/></equal>
            <equal><clip pos="2" part="art"/><lit-tag v="def"/></equal>
          </or></test>
          <call-macro n="set_ana"><with-param pos="2"/></call-macro>
        </when></choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="NOM: synspunkt
                   Just set_ana">
      <pattern>
        <pattern-item n="nom"/>
      </pattern>
      <action>
        <choose><when c="only set ana based on det if no ana, or if n is def">
          <test><or>
            <equal><var n="ana_nbr"/><lit v=""/></equal>
            <equal><clip pos="1" part="art"/><lit-tag v="def"/></equal>
          </or></test>
          <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        </when></choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET ADV NOM: et meget stort antall => ei særs stor mengd">
      <pattern>
        <pattern-item n="det"/>
        <pattern-item n="adv"/>
        <pattern-item n="nom"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <choose>
          <when c="don't change gender for '(er) dette kjernen' etc.">
            <test><and>
              <equal><clip pos="1" part="gen"/><lit-tag v="nt"/></equal>
              <not><equal><clip pos="3" part="sl-gen"/><lit-tag v="sl-nt"/></equal></not>
            </and></test>
            <!-- TODO: reject-current-rule in interchunk -->
            <!-- <reject-current-rule shifting="no"/> -->
          </when>
          <otherwise>
            <call-macro n="modify_det_gender2.n.det"><with-param pos="3"/><with-param pos="1"/></call-macro>
            <call-macro n="set_n_defness"><with-param pos="3"/><with-param pos="1"/></call-macro>
          </otherwise>
        </choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DETIND DETIND NIND: en annen kvinne => ei anna kvinne">
      <pattern>
        <pattern-item n="detind"/>
        <pattern-item n="detind"/>
        <pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <choose><when c="don't change gender for 'det andre kvinner' etc.">
          <test>
            <or>
              <and>
                <in><clip pos="1" part="gen"/><list n="nt_GD"/></in>
                <in><clip pos="3" part="sl-gen"/><list n="nt_GD"/></in>
              </and>
              <and>
                <in><clip pos="1" part="gen"/><list n="m_f_mf_GD"/></in>
                <in><clip pos="3" part="sl-gen"/><list n="m_f_mf_GD"/></in>
              </and>
            </or>
          </test>
          <call-macro n="modify_det_gender2.n.det"><with-param pos="3"/><with-param pos="1"/></call-macro>
        </when></choose>
        <choose><when c="don't change gender for 'den eget kvinner' etc.">
          <test>
            <or>
              <and>
                <in><clip pos="2" part="gen"/><list n="nt_GD"/></in>
                <in><clip pos="3" part="sl-gen"/><list n="nt_GD"/></in>
              </and>
              <and>
                <in><clip pos="2" part="gen"/><list n="m_f_mf_GD"/></in>
                <in><clip pos="3" part="sl-gen"/><list n="m_f_mf_GD"/></in>
              </and>
            </or>
          </test>
          <call-macro n="modify_det_gender2.n.det"><with-param pos="3"/><with-param pos="2"/></call-macro>
        </when></choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET PREP_AV NPLDEF: en av kvinnene => ei av kvinnene">
      <pattern>
        <pattern-item n="det"/>
        <pattern-item n="prep_av"/>
        <pattern-item n="npldef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="3"/></call-macro>
        <choose>
          <when c="don't change gender for '(er) dette av kjernen' etc.">
            <test><and>
              <equal><clip pos="1" part="gen"/><lit-tag v="nt"/></equal>
              <not><equal><clip pos="3" part="sl-gen"/><lit-tag v="sl-nt"/></equal></not>
            </and></test>
            <!-- TODO: reject-current-rule in interchunk -->
            <!-- <reject-current-rule shifting="no"/> -->
          </when>
          <otherwise>
            <choose c="can't use modify_det_gender2.n.det since that disallows plural nouns">
              <when>
                <test><and>
                  <not><equal><clip pos="3" part="gen"/><lit v=""/></equal></not>
                  <not><equal><clip pos="1" part="nbr"/><lit-tag v="pl"/></equal></not>
                </and></test>
                <let><clip pos="1" part="gen"/><clip pos="3" part="gen"/></let>
              </when>
            </choose>
            <call-macro n="set_n_defness"><with-param pos="3"/><with-param pos="1"/></call-macro>
          </otherwise>
        </choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET PREP_AV DETDEM NPLDEF: en av de siste kvinnene => ei av dei siste kvinnene">
      <pattern>
        <pattern-item n="det"/>
        <pattern-item n="prep_av"/>
        <pattern-item n="detdem"/>
        <pattern-item n="npldef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="4"/></call-macro>
        <choose>
          <when c="don't change gender for '(er) dette av kjernen' etc.">
            <test><and>
              <equal><clip pos="1" part="gen"/><lit-tag v="nt"/></equal>
              <not><equal><clip pos="4" part="sl-gen"/><lit-tag v="sl-nt"/></equal></not>
            </and></test>
            <!-- TODO: reject-current-rule in interchunk -->
            <!-- <reject-current-rule shifting="no"/> -->
          </when>
          <otherwise>
            <choose c="can't use modify_det_gender2.n.det since that disallows plural nouns">
              <when>
                <test><and>
                  <not><equal><clip pos="4" part="gen"/><lit v=""/></equal></not>
                  <not><equal><clip pos="1" part="nbr"/><lit-tag v="pl"/></equal></not>
                </and></test>
                <let><clip pos="1" part="gen"/><clip pos="4" part="gen"/></let>
              </when>
            </choose>
            <call-macro n="set_n_defness"><with-param pos="4"/><with-param pos="1"/></call-macro>
          </otherwise>
        </choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="4" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET PREP_AV DETDEM DETQNT NPLDEF: en av de tre siste kvinnene => ei av dei tre siste kvinnene">
      <pattern>
        <pattern-item n="det"/>
        <pattern-item n="prep_av"/>
        <pattern-item n="detdem"/>
        <pattern-item n="detqnt"/>
        <pattern-item n="npldef"/>
      </pattern>
      <action>
        <call-macro n="set_ana"><with-param pos="5"/></call-macro>
        <choose>
          <when c="don't change gender for '(er) dette av kjernen' etc.">
            <test><and>
              <equal><clip pos="1" part="gen"/><lit-tag v="nt"/></equal>
              <not><equal><clip pos="5" part="sl-gen"/><lit-tag v="sl-nt"/></equal></not>
            </and></test>
            <!-- TODO: reject-current-rule in interchunk -->
            <!-- <reject-current-rule shifting="no"/> -->
          </when>
          <otherwise>
            <choose c="can't use modify_det_gender2.n.det since that disallows plural nouns">
              <when>
                <test><and>
                  <not><equal><clip pos="5" part="gen"/><lit v=""/></equal></not>
                  <not><equal><clip pos="1" part="nbr"/><lit-tag v="pl"/></equal></not>
                </and></test>
                <let><clip pos="1" part="gen"/><clip pos="5" part="gen"/></let>
              </when>
            </choose>
            <call-macro n="set_n_defness"><with-param pos="5"/><with-param pos="1"/></call-macro>
          </otherwise>
        </choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
          <b pos="1"/>
          <chunk><clip pos="2" part="whole"/></chunk>
          <b pos="2"/>
          <chunk><clip pos="3" part="whole"/></chunk>
          <b pos="3"/>
          <chunk><clip pos="4" part="whole"/></chunk>
          <b pos="4"/>
          <chunk><clip pos="5" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET">
      <pattern>
        <pattern-item n="det"/>
      </pattern>
      <action>
        <choose><when c="only set ana based on det if no ana, or if det is expl">
          <test><or>
            <equal><var n="ana_nbr"/><lit v=""/></equal>
            <equal><clip pos="1" part="expl"/><lit-tag v="expl"/></equal>
          </or></test>
          <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        </when></choose>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
        </out>
      </action>
    </rule>
    <rule comment="PRN">
      <pattern>
        <pattern-item n="prn"/>
      </pattern>
      <action>
        <call-macro n="modify_prn_gen"><with-param pos="1"/></call-macro>
        <call-macro n="set_ana"><with-param pos="1"/></call-macro>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
        </out>
      </action>
    </rule>

    <rule comment="SENT">
      <pattern>
        <pattern-item n="sent"/>
      </pattern>
      <action>
        <let><var n="ana_nbr"/><lit v=""/></let>
        <let><var n="ana_gen"/><lit v=""/></let>
        <out>
          <chunk><clip pos="1" part="whole"/></chunk>
        </out>
      </action>
    </rule>

  </section-rules>
</interchunk>
