<?xml version="1.0" encoding="UTF-8"?>
<!-- -*- nxml -*- -->
<!-- todo: stop using GD, just check whether the determiner (or whatever) has some gender already -->
<interchunk>

  <section-def-cats>
    <def-cat n="nom">
      <cat-item tags="n.*.*.*"/>
      <cat-item tags="n.*.*.*.gen"/>
      <cat-item tags="np.*"/>
    </def-cat>
    <def-cat n="nind">
      <cat-item tags="n.*.*.ind"/>
    </def-cat>
    <def-cat n="ndef">
      <cat-item tags="n.*.*.def"/>
    </def-cat>
    <def-cat n="ngen">
      <cat-item tags="n.*.*.*.gen"/>
    </def-cat>
    <def-cat n="posgen">
      <cat-item tags="det.pos.*"/>
      <cat-item tags="n.*.*.*.gen"/>
    </def-cat>
    <def-cat n="det">
      <cat-item tags="det.*"/>
    </def-cat>
    <def-cat n="detpos">
      <cat-item tags="det.pos.*"/>
    </def-cat>
    <def-cat n="detnonpos">
      <cat-item tags="det.def.*"/>
      <cat-item tags="det.dem.*"/>
      <cat-item tags="det.emph.*"/>
      <cat-item tags="det.itg.*"/>
      <cat-item tags="det.qnt.*"/>
    </def-cat>
  </section-def-cats>
  
  <section-def-attrs>
    <def-attr n="a_nom">
      <attr-item tags="n"/>
      <attr-item tags="n.acr"/>
      <attr-item tags="np"/>
      <attr-item tags="np.top"/>
    </def-attr>    
    <def-attr n="ep">
      <attr-item tags="ep-s"/>
      <attr-item tags="ep-Ø"/>
    </def-attr>
    <def-attr n="a_adj">
      <attr-item tags="adj"/>
      <attr-item tags="adj.pp"/>
      <attr-item tags="adj.pprs"/>
      <attr-item tags="adj.posi"/>
      <attr-item tags="adj.comp"/>
      <attr-item tags="adj.sup"/>
      <attr-item tags="adj.ord.posi"/>
      <attr-item tags="adj.ord.comp"/>
      <attr-item tags="adj.ord.sup"/>
    </def-attr>
    <def-attr n="persona">
      <attr-item tags="p1"/>
      <attr-item tags="p2"/>
      <attr-item tags="p3"/>
    </def-attr>
    <def-attr n="a_verb">
      <attr-item tags="vblex"/>
      <attr-item tags="vblex.pstv"/>
    </def-attr>
    <def-attr n="temps">
      <attr-item tags="inf"/>
      <attr-item tags="imp"/>
      <attr-item tags="pres"/>
      <attr-item tags="pret"/>
      <attr-item tags="pp"/>
    </def-attr>
    <def-attr n="voice">
      <attr-item tags="pass"/>
    </def-attr>
    <def-attr n="a_det">
      <attr-item tags="det"/> 
      <attr-item tags="det.emph"/>
      <attr-item tags="det.dem"/>
      <attr-item tags="det.itg"/>
      <attr-item tags="det.qnt"/>
      <attr-item tags="det.qnt.neg"/>
      <attr-item tags="det.pos"/>
    </def-attr>
    <def-attr n="gen">
      <attr-item tags="m"/>
      <attr-item tags="mf"/>
      <attr-item tags="nt"/>
      <attr-item tags="f"/>
      <attr-item tags="GD"/>
    </def-attr>
    <def-attr n="nbr">
      <attr-item tags="sg"/>
      <attr-item tags="pl"/>
      <attr-item tags="sp"/>
      <attr-item tags="ND"/>
    </def-attr>
    <def-attr n="cas">
      <attr-item tags="nom"/>
      <attr-item tags="gen"/>
      <attr-item tags="acc"/>
      <attr-item tags="CD"/>
    </def-attr>
    <def-attr n="art">
      <attr-item tags="def"/>
      <attr-item tags="ind"/>
    </def-attr>
  </section-def-attrs>


  <section-def-vars>
    <def-var n="caseFirstWord"/>
    <def-var n="det_gender"/>
    <def-var n="number"/>  
    <def-var n="number_no_sp"/>  
    <def-var n="adj_number"/>  
    <def-var n="adj_gender"/>  
    <def-var n="adj_defness"/>  
    <def-var n="n_number"/>
    <def-var n="case"/>
    <def-var n="pass"/>
    <def-var n="epenthetic"/>
    <def-var n="n_defness"/>
    <def-var n="lemh"/>
  </section-def-vars>


  <section-def-lists>

    <!-- POSSESSED-DEPENDENT EXCEPTIONS TODO: omkretsen til verda,
         lengden på dokumentet, ryktet til styret, lukta av/etter
         kua... (although this could be coded in all the dictionaries,
         or added by CG, it's probably simpler and more compact to do
         it with def-list and macros) -->
    <def-list n="gen-i">
      <list-item v="verd"/>
      <list-item v="by"/>
      <list-item v="dal"/>
      <list-item v="luft"/>
      <list-item v="radio"/>
      <list-item v="hav"/>
      <list-item v="ryggmarg"/>
      <list-item v="styre"/>
      <list-item v="fylke"/>
      <list-item v="hus"/>
      <list-item v="ferie"/>
      <list-item v="sak"/>
      <list-item v="århundre"/>
      <list-item v="dokument"/>
    </def-list>
    <def-list n="gen-på">
      <list-item v="måndag"/>
      <list-item v="tysdag"/>
      <list-item v="onsdag"/>
      <list-item v="torsdag"/>
      <list-item v="fredag"/>
      <list-item v="laurdag"/>
      <list-item v="søndag"/>
      <list-item v="dag"/>
      <list-item v="øy"/>
      <list-item v="topp"/>
      <list-item v="kjøkken"/>
    </def-list>
    

    
  </section-def-lists>

  <section-def-macros>

    <!-- Macros which set concordance variables etc.: -->
    <def-macro n="switch_cases" npar="2">
      <let><var n="caseFirstWord"/><get-case-from pos="1"><clip pos="1" part="lemh"/></get-case-from></let>
      <let><clip pos="1" part="lemh"/><get-case-from pos="2"><clip pos="1" part="lemh"/></get-case-from></let>
      <modify-case><clip pos="2" part="lemh"/><var n="caseFirstWord"/></modify-case>
    </def-macro>

    <def-macro n="get_case_from_detpos" npar="2">
      <!-- arg.1: possessed noun. arg.2: det.pos, gives typographic case -->
      <choose>
        <when>
          <test>
            <and>
              <equal><clip pos="2" part="lemh"/><lit v="De"/></equal>
              <equal><clip pos="2" part="a_det"/><lit-tag v="det.pos"/></equal>
              <equal><clip pos="2" part="persona"/><lit-tag v="p2"/></equal>
            </and>
          </test>
          <let><var n="lemh"/><clip pos="1" part="lemh"/></let>
        </when>
        <otherwise>
          <let><var n="lemh"/><get-case-from pos="2"><clip pos="1" part="lemh"/></get-case-from></let>
        </otherwise>
      </choose>      
    </def-macro>
    <def-macro n="modify_case_detpos" npar="2">
      <!-- arg.1: possessed noun. arg.2: det.pos, gives typographic case
           Workaround for Polite forms.
      -->
      <choose>
        <when>
          <test><not>
            <and>
              <equal><clip pos="2" part="lemh"/><lit v="De"/></equal>
              <equal><clip pos="2" part="a_det"/><lit-tag v="det.pos"/></equal>
              <equal><clip pos="2" part="persona"/><lit-tag v="p2"/></equal>
            </and>
          </not></test>
          <modify-case><clip pos="2" part="lemh"/><clip pos="1" part="lemh"/></modify-case>
        </when>
      </choose>      
    </def-macro>
    <def-macro n="set_number1" npar="1">
      <let><var n="number"/><clip pos="1" part="nbr"/></let>
      <let><var n="number_no_sp"/><var n="number"/></let>
      <choose><when>
        <test><or>
          <equal><var n="number"/><lit-tag v="sp"/></equal>
          <equal><var n="number"/><lit v=""/></equal>
        </or></test>
        <let><var n="number_no_sp"/><lit-tag v="pl"/></let>
      </when></choose>
    </def-macro>
    <def-macro n="set_number2" npar="2">
      <!-- arg.1: noun, arg.2: determiner or adjective
      sets number and n_number
      - If number is sp or empty (or noun actually is sp), use nbr
        from noun. Eg. <adj><pp> doesn't have a number, so in that case
        use noun.
      - If we've been given an adjective, and the noun is sg def,
        we can be pretty sure the noun is right about this, so go with
        sg def (set_adj_GND should make sure we add the def if adjective
        is plural). And the other way around, pl noun versus adjective
        is sure not to be sg def.
      -->      
      <call-macro n="set_number1"><with-param pos="2"/></call-macro>
      
      <choose><when>
	  <test><equal><var n="number"/><lit-tag v="ND"/></equal></test>
          <let><var n="number"/><clip pos="1" part="nbr"/></let>
      </when></choose>
      
      <let><var n="n_number"/><var n="number"/></let>
      
      <choose><when>
        <test><or>
          <equal><clip pos="2" part="a_adj"/><lit-tag v="adj.pp"/></equal>
          <ends-with><clip pos="2" part="a_adj"/><lit-tag v="posi"/></ends-with>
        </or></test>
        <choose><when>
          <test><and>
            <equal><clip pos="1" part="nbr"/><lit-tag v="sg"/></equal>
            <equal><clip pos="1" part="art"/><lit-tag v="def"/></equal>
          </and></test>
          <let><var n="number"/><lit-tag v="sg"/></let>
        </when></choose>
        <choose><when>
          <test><equal><clip pos="1" part="nbr"/><lit-tag v="pl"/></equal></test>
          <let><var n="number"/><lit-tag v="pl"/></let>
        </when></choose>
        <let><var n="n_number"/><var n="number"/></let>
      </when></choose>
      
      <choose><when>
        <test><or>
          <equal><var n="n_number"/><lit-tag v="sp"/></equal>
          <equal><var n="n_number"/><lit v=""/></equal>
          <equal><clip pos="1" part="nbr"/><lit-tag v="sp"/></equal>
        </or></test>
        <let><var n="n_number"/><clip pos="1" part="nbr"/></let>
      </when>
      </choose>
      
      <choose><when>
        <test><or>
          <begins-with><clip pos="1" part="a_nom"/><lit-tag v="np"/></begins-with>
          <ends-with><clip pos="1" part="a_nom"/><lit-tag v="acr"/></ends-with>
        </or></test>
        <let><var n="n_number"/><lit v=""/></let>
      </when></choose>
      
    </def-macro>
    <def-macro n="set_adj_number" npar="1">
      <!-- arg.1: adjective
           
           Assumes that set_number is called!

           Number is only a feature of positive/pp adjectives. Use
           variable "number" for these unless it's empty/sp.
      -->
      <let><var n="adj_number"/><lit v=""/></let>
      <choose><when>
        <test><or>
          <equal><clip pos="1" part="a_adj"/><lit-tag v="adj.pp"/></equal>
          <ends-with><clip pos="1" part="a_adj"/><lit-tag v="posi"/></ends-with>
        </or></test>
        
        <let><var n="adj_number"/><var n="number"/></let>
        
        <choose><when>
          <test><or>
            <equal><var n="adj_number"/><lit v=""/></equal>
            <equal><var n="adj_number"/><lit-tag v="sp"/></equal>
          </or></test>
          <let><var n="adj_number"/><clip pos="1" part="nbr"/></let>
        </when></choose>
      </when></choose>
    </def-macro>
    
    <def-macro n="set_gender1" npar="1">
      <!-- arg.1: determiner
	   - iff sg and GD, take a wild guess and go for m;
	   - o/w take gender of target determiner;
      -->
      <call-macro n="set_number1"><with-param pos="1"/></call-macro>
      <choose>
        <when>
          <test><and>
            <equal><var n="number"/><lit-tag v="sg"/></equal>
            <equal><clip pos="1" part="gen"/><lit-tag v="GD"/></equal>
          </and></test>
	  <let><clip pos="1" part="gen"/><lit-tag v="m"/></let>
        </when>
      </choose>
      <let><var n="det_gender"/><clip pos="1" part="gen"/></let>
    </def-macro>

    
    <def-macro n="set_gender2.n.det" npar="2"
               c="arg.1: noun, arg.2: determiner (or noun)
                  - if a noun is given as arg.2, use set_gender1 instead (but
                  set_number2 with arg.1); this is just so we can generalise
                  with the POSGEN category
           Note: does not set adj_GND, use set_gender3 or an explicit call to set_adj_GND.">
      <choose>
        <when>                            <!-- if arg.2 is a noun: -->
          <test><begins-with><clip pos="2" part="a_nom"/><lit-tag v="n"/></begins-with></test>
          <call-macro n="set_gender1"><with-param pos="1"/></call-macro>
          <call-macro n="set_number2"><with-param pos="1"/><with-param pos="1"/></call-macro>
        </when>
        <otherwise>
          <call-macro n="set_number2"><with-param pos="1"/><with-param pos="2"/></call-macro>
          <choose>
            <when>
              <test><not>
                <equal><clip pos="1" part="gen"/><lit v=""/></equal>
              </not></test>
              <let><clip pos="2" part="gen"/><clip pos="1" part="gen"/></let>
            </when>
          </choose>
        </otherwise>        
      </choose>
      <choose>
        <when>
          <test><and>
            <equal><var n="number"/><lit-tag v="sg"/></equal>
            <equal><clip pos="1" part="gen"/><lit-tag v="GD"/></equal>
          </and></test>
	  <let><clip pos="1" part="gen"/><lit-tag v="m"/></let>
        </when>
      </choose>
      <let><var n="det_gender"/><clip pos="1" part="gen"/></let>
    </def-macro>
    <def-macro n="set_adj_GND" npar="1">
      <!-- arg.1: adjective
           
           Assumes that number and det_gender are set! Only make changes
           for GD-marked adjectives.

           adj_gender is either nt, f or mf. Most adjectives only have
           nt or mf forms, some also have an f form. These we need to
           mark in bidix (nb <mf> => <GD>, nb <f> => <f>). <GD> turns
           into noun gender (or <mf> as fallback); however, we never
           use nn <m> so any <m> noun turns into <mf> adj_gender.
      -->
      <let><var n="adj_gender"/><clip pos="1" part="gen"/></let>
      <let><var n="adj_number"/><clip pos="1" part="nbr"/></let>
      <let><var n="adj_defness"/><clip pos="1" part="art"/></let>

      <choose><when>
          <test><equal><var n="adj_gender"/><lit-tag v="GD"/></equal></test>
          
          <call-macro n="set_adj_number"><with-param pos="1"/></call-macro>
          
          <choose><when>
            <test><equal><var n="adj_number"/><lit-tag v="sg"/></equal></test>
            <choose><when>
              <test><not><equal><var n="det_gender"/><lit v=""/></equal></not></test>            
              <let><var n="adj_gender"/><var n="det_gender"/></let>
            </when></choose>
            <choose><when>
              <test><or>
                <equal><var n="adj_gender"/><lit-tag v="m"/></equal>
                <equal><var n="adj_gender"/><lit-tag v="GD"/></equal>
              </or></test>
              <let><var n="adj_gender"/><lit-tag v="mf"/></let>
            </when></choose>
            <let><var n="adj_defness"/><lit-tag v="ind"/></let>
            <choose><when>
              <test><equal><var n="adj_gender"/><lit v=""/></equal></test>            
              <let><var n="adj_defness"/><lit-tag v="sg"/></let>
            </when></choose>
          </when></choose>
          
          <choose><when>
            <test><equal><var n="adj_number"/><lit-tag v="pl"/></equal></test>
            <let><var n="adj_gender"/><lit v=""/></let>
            <choose><when>
              <test><equal><var n="adj_defness"/><lit-tag v="ind"/></equal></test>            
              <let><var n="adj_defness"/><lit v=""/></let>
            </when></choose>
          </when></choose>
      </when></choose>

    </def-macro>
    <def-macro n="set_gender2.n.adj" npar="2">
      <!-- arg.1: noun, arg.2: adjective -->
      <call-macro n="set_gender2.n.det"><with-param pos="1"/><with-param pos="1"/></call-macro>
      <call-macro n="set_adj_GND"><with-param pos="2"/></call-macro>
    </def-macro>


    <def-macro n="set_n_defness" npar="2">
      <!-- arg.1: noun, arg.2: determiner
           Make sure we have double definiteness marking, eg.:
           disse<def> friheter<ind> => desse<def> fridomane<def>
           TODO: make sure def. adjectives get def nouns too
      -->
      <choose>
        <when>
          <test>
            <and>
              <equal><clip pos="1" part="art"/><lit-tag v="ind"/></equal>
              <equal caseless="yes"><clip pos="2" part="lemh"/><lit v="detdd"/></equal>
            </and>
          </test>
          <let><clip pos="1" part="art"/><lit-tag v="def"/></let>
        </when>
      </choose>
    </def-macro>

    <!-- Output macros: -->
    <def-macro n="out_det_when_adj" npar="2"
               c="arg.1: adj, arg.2: gives typographic case to adj">
      <choose><when>
        <test><begins-with caseless="yes"><clip pos="1" part="lemh"/><lit v="adj"/></begins-with></test>
        <out><chunk>
          <get-case-from pos="1"><lit v="det"/></get-case-from>
          <lit-tag v="det.dem"/>
          <var n="det_gender"/>
          <var n="number_no_sp"/>
          <lit v="{^"/>
          <get-case-from pos="1"><lit v="den"/></get-case-from>
          <lit-tag v="det.dem"/>
          <var n="det_gender"/>
          <var n="number_no_sp"/>
          <lit v="$}"/>
        </chunk><b/></out>
        <let><clip pos="1" part="lemh"/><get-case-from pos="2"><clip pos="1" part="lemh"/></get-case-from></let>
      </when></choose>
    </def-macro>
    <def-macro n="out_gen_prep" npar="1">
      <!-- arg.1: possessor noun. Note: puts a space _after_ the preposition. -->
      <choose>
        <when>
          <test><in><clip pos="1" part="lemh"/><list n="gen-i"/></in></test>
          <out>
            <chunk>
              <lit v="{^i"/>
              <lit-tag v="pr"/>
              <lit v="$}"/>
            </chunk>
            <b/>
          </out>
        </when>
        <when>
          <test><in><clip pos="1" part="lemh"/><list n="gen-på"/></in></test>
          <out>
            <chunk>
              <lit v="{^på"/>
              <lit-tag v="pr"/>
              <lit v="$}"/>
            </chunk>
            <b/>
          </out>
        </when>
        <otherwise>
          <out>
            <chunk>
              <lit v="{^til"/>
              <lit-tag v="pr"/>
              <lit v="$}"/>
            </chunk>
            <b/>
          </out>
        </otherwise>
      </choose>
    </def-macro>
    <def-macro n="out_ndef" npar="2">
      <!-- arg.1: possessed noun. arg.2 gives typographic case
           
           Strip case, add definiteness.  -->
      <call-macro n="get_case_from_detpos">
        <with-param pos="1"/>
        <with-param pos="2"/>
      </call-macro>
      <let><clip pos="1" part="art"/><lit-tag v="def"/></let>
      <out>
        <chunk><clip pos="1" part="whole"/></chunk>
      </out>
    </def-macro>
    
    <def-macro n="out_posgen" npar="1">
      <!-- arg.1: possessor, either genitive noun or det.pos.
           Assumes that "det_gender" and "number" are set.
           Choose 'til NOUN' unless we have a determiner. Only determiners
           use variable gender and number-->
      <choose><when>
        <test><equal><clip pos="1" part="a_det"/><lit-tag v="det.pos"/></equal></test>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
        </out>
      </when>
      <otherwise>
        <call-macro n="out_gen_prep">
          <with-param pos="1"/>
        </call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
        </out>
      </otherwise>
      </choose>  
    </def-macro>

    <def-macro n="out_sin" npar="1">
      <call-macro n="set_gender1"><with-param pos="1"/></call-macro>
      <out><chunk>
        <lit v="det"/>
        <var n="det_gender"/>
        <var n="number_no_sp"/>
        <lit v="{^seg"/>
        <lit-tag v="det.pos"/>
        <var n="det_gender"/>
        <var n="number_no_sp"/>
        <lit v="$}"/>
      </chunk></out>
    </def-macro>

  </section-def-macros>




  <section-rules>  
    <!-- Possessive noun phrases -->
    

    <!-- The regular possessive noun phrases, with more complex
         transfer operations.-->
    <rule comment="NGEN: mannens => mannen sin
                   Very heuristic fallback rule.
                   If we can't match with the below rules, turn the
                   genitive -s into 'sin' garpegenitiv instead.
                   A bit more fluent where eg. input is incomplete:
                         mannens *sykkel => mannen sin *sykkel
                   But we don't know gen/nbr of object, so we could end
                   up with
                         mannens *sykler => mannen sin *sykler
                   So let's just hope plurals possess plurals etc...">
      <pattern>
        <pattern-item n="ngen"/>
      </pattern>
      <action>
        <out>
          <chunk>
          <clip pos="1" part="whole"/>
          </chunk>
          <b/> 
        </out>
        <call-macro n="out_sin"><with-param pos="1"/></call-macro>
      </action>
    </rule>
    <rule comment="NDEF: lille menneske => det vesle mennesket">
      <pattern>
        <pattern-item n="ndef"/>
      </pattern>
      <action>
        <call-macro n="modify_case_detpos"><with-param pos="1"/><with-param pos="1"/></call-macro>
        <call-macro n="set_gender2.n.det"><with-param pos="1"/><with-param pos="1"/></call-macro>

        <call-macro n="out_det_when_adj"><with-param pos="1"/><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    <rule comment="DETNONPOS NGEN: det forfatterskapets => den forfattarskapen sin">
      <pattern>
        <pattern-item n="detnonpos"/>
        <pattern-item n="ngen"/>
      </pattern>
      <action>
        <call-macro n="set_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
          <b/>
        </out>
        <call-macro n="out_sin"><with-param pos="2"/></call-macro>
      </action>
    </rule>
    
    <rule comment="POSGEN NIND: naboens bil => bilen til naboen
                                min mor => mora mi
                                ditt hus => huset ditt
                                naboens røde bil => den røde bilen til naboen
                   nind makes sure we don't match 'min Per(np)' nor 'min bils(gen)'
                   Third example shows how determiners ..um..determine number.">
      <pattern>
        <pattern-item n="posgen"/>
        <pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="switch_cases"><with-param pos="2"/><with-param pos="1"/></call-macro>
<!--         <call-macro n="modify_case_detpos"><with-param pos="2"/><with-param pos="1"/></call-macro> -->
        <call-macro n="set_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>

        <call-macro n="out_det_when_adj"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <out><b pos="1"/></out>
        <call-macro n="out_posgen"><with-param pos="1"/></call-macro>
      </action>
    </rule>

    
    <rule comment="POSGEN NGEN NIND: min katts snute => snuten til katten min
                                     naboens katts snute => snuten til katten til naboen
                                     (but not *'min din snute')">
      <pattern>
	<pattern-item n="posgen"/>    
	<pattern-item n="ngen"/>
	<pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="switch_cases"><with-param pos="3"/><with-param pos="1"/></call-macro>
	<call-macro n="set_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <call-macro n="out_det_when_adj"><with-param pos="3"/><with-param pos="1"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="3"/><with-param pos="1"/></call-macro>

        <out><b pos="1"/></out>
        <call-macro n="out_gen_prep"><with-param pos="2"/></call-macro>

        <call-macro n="out_det_when_adj"><with-param pos="2"/><with-param pos="2"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="2"/><with-param pos="2"/></call-macro>
        <out> <b pos="2"/> </out>
        <call-macro n="out_posgen"><with-param pos="1"/></call-macro>
      </action>
    </rule>

    <rule comment="DETNONPOS NGEN NIND: en katts snute => snuten til ein katt">
      <pattern>
	<pattern-item n="detnonpos"/>    
	<pattern-item n="ngen"/>
	<pattern-item n="nind"/>
      </pattern>
      <action>
        <call-macro n="switch_cases"><with-param pos="3"/><with-param pos="1"/></call-macro>
        <call-macro n="set_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <call-macro n="out_det_when_adj"><with-param pos="3"/><with-param pos="1"/></call-macro>
        <call-macro n="out_ndef"><with-param pos="3"/><with-param pos="1"/></call-macro>

        <out><b pos="1"/></out>
        <call-macro n="out_gen_prep"><with-param pos="2"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="2"/>
          <chunk>
            <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="NDEF DETPOS: jenten min => jenta mi">
      <pattern>
        <pattern-item n="ndef"/>
        <pattern-item n="detpos"/>
      </pattern>
      <action>
        <call-macro n="set_gender2.n.det"><with-param pos="1"/><with-param pos="2"/></call-macro>
        <out>
          <chunk>
	    <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
	    <clip pos="2" part="whole"/>
          </chunk>          
        </out>
      </action>
    </rule>

    <rule comment="DET NOM: en kvinne => ei kvinne
		            hvilken jente => kva for ei jente
			    egne hus => eigne hus
			    et Norge => eit Noreg
                            dette hus => dette huset
	           np får ikkje noko tal i den siste.">
      <pattern>
        <pattern-item n="det"/>
        <pattern-item n="nom"/>
      </pattern>
      <action>
        <call-macro n="set_gender2.n.det"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <call-macro n="set_n_defness"><with-param pos="2"/><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
          <b pos="1"/>
          <chunk>
	    <clip pos="2" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="DET: en => ein
		   Frequency is on our side, but politically incorrect..hmm..">
      <pattern>
        <pattern-item n="det"/>
      </pattern>
      <action>
        <call-macro n="set_gender1"><with-param pos="1"/></call-macro>
        <out>
          <chunk>
            <clip pos="1" part="whole"/>
          </chunk>
        </out>
      </action>
    </rule>
    
  </section-rules>  
</interchunk>
